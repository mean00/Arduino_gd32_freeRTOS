/* automatically generated by rust-bindgen 0.55.1 */

pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub const GpioMode_lnFLOATING: GpioMode = 0;
pub const GpioMode_lnINPUT_FLOATING: GpioMode = 0;
pub const GpioMode_lnINPUT_PULLUP: GpioMode = 2;
pub const GpioMode_lnINPUT_PULLDOWN: GpioMode = 3;
pub const GpioMode_lnOUTPUT: GpioMode = 1;
pub const GpioMode_lnOUTPUT_OPEN_DRAIN: GpioMode = 4;
pub const GpioMode_lnALTERNATE_PP: GpioMode = 5;
pub const GpioMode_lnALTERNATE_OD: GpioMode = 6;
pub const GpioMode_lnPWM: GpioMode = 7;
pub const GpioMode_lnADC_MODE: GpioMode = 8;
pub const GpioMode_lnDAC_MODE: GpioMode = 9;
pub type GpioMode = ::std::os::raw::c_uint;
pub type lnPin = ::std::os::raw::c_int;
extern "C" {
    #[link_name = "\u{1}_Z9lnPinModei8GpioMode"]
    pub fn lnPinMode(pin: lnPin, mode: GpioMode);
}
extern "C" {
    #[link_name = "\u{1}_Z14lnDigitalWriteib"]
    pub fn lnDigitalWrite(pin: lnPin, value: bool);
}
extern "C" {
    #[link_name = "\u{1}_Z13lnDigitalReadi"]
    pub fn lnDigitalRead(pin: lnPin) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z15lnDigitalTogglei"]
    pub fn lnDigitalToggle(pin: lnPin);
}
extern "C" {
    #[link_name = "\u{1}_Z23lnGetGpioToggleRegisteri"]
    pub fn lnGetGpioToggleRegister(port: ::std::os::raw::c_int) -> *mut u32;
}
extern "C" {
    #[link_name = "\u{1}_Z26lnGetGpioDirectionRegisteri"]
    pub fn lnGetGpioDirectionRegister(port: ::std::os::raw::c_int) -> *mut u32;
}
extern "C" {
    #[link_name = "\u{1}_Z22lnGetGpioValueRegisteri"]
    pub fn lnGetGpioValueRegister(port: ::std::os::raw::c_int) -> *mut u32;
}
extern "C" {
    #[link_name = "\u{1}_Z10lnReadPorti"]
    pub fn lnReadPort(port: ::std::os::raw::c_int) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_Z15lnRemapTimerPini"]
    pub fn lnRemapTimerPin(timer: ::std::os::raw::c_int);
}
#[doc = " @param p"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lnFastIO {
    pub _onoff: *mut u32,
    pub _onbit: u32,
    pub _offbit: u32,
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnFastIOC1Ei"]
    pub fn lnFastIO_lnFastIO(this: *mut lnFastIO, p: lnPin);
}
impl lnFastIO {
    #[inline]
    pub unsafe fn new(p: lnPin) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        lnFastIO_lnFastIO(__bindgen_tmp.as_mut_ptr(), p);
        __bindgen_tmp.assume_init()
    }
}
pub const lnEdge_LN_EDGE_NONE: lnEdge = 0;
pub const lnEdge_LN_EDGE_RISING: lnEdge = 1;
pub const lnEdge_LN_EDGE_FALLING: lnEdge = 2;
pub const lnEdge_LN_EDGE_BOTH: lnEdge = 3;
pub type lnEdge = ::std::os::raw::c_uint;
pub type lnExtiCallback =
    ::std::option::Option<unsafe extern "C" fn(pin: lnPin, cookie: *mut ::std::os::raw::c_void)>;
extern "C" {
    #[link_name = "\u{1}_Z21lnExtiAttachInterrupti6lnEdgePFviPvES0_"]
    pub fn lnExtiAttachInterrupt(
        pin: lnPin,
        edge: lnEdge,
        cb: lnExtiCallback,
        cookie: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z21lnExtiDetachInterrupti"]
    pub fn lnExtiDetachInterrupt(pin: lnPin);
}
extern "C" {
    #[link_name = "\u{1}_Z21lnExtiEnableInterrupti"]
    pub fn lnExtiEnableInterrupt(pin: lnPin);
}
extern "C" {
    #[link_name = "\u{1}_Z22lnExtiDisableInterrupti"]
    pub fn lnExtiDisableInterrupt(pin: lnPin);
}
#[doc = " Type by which queues are referenced.  For example, a call to xQueueCreate()"]
#[doc = " returns an QueueHandle_t variable that can then be used as a parameter to"]
#[doc = " xQueueSend(), xQueueReceive(), etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueueDefinition {
    _unused: [u8; 0],
}
pub type QueueHandle_t = *mut QueueDefinition;
pub type SemaphoreHandle_t = QueueHandle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xBinarySemaphore {
    pub _handle: SemaphoreHandle_t,
}
extern "C" {
    #[link_name = "\u{1}_ZN16xBinarySemaphore4takeEv"]
    pub fn xBinarySemaphore_take(this: *mut xBinarySemaphore) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16xBinarySemaphore7tryTakeEv"]
    pub fn xBinarySemaphore_tryTake(this: *mut xBinarySemaphore) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16xBinarySemaphore4takeEi"]
    pub fn xBinarySemaphore_take1(
        this: *mut xBinarySemaphore,
        timeoutMs: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16xBinarySemaphore4giveEv"]
    pub fn xBinarySemaphore_give(this: *mut xBinarySemaphore) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN16xBinarySemaphoreC1Ev"]
    pub fn xBinarySemaphore_xBinarySemaphore(this: *mut xBinarySemaphore);
}
impl xBinarySemaphore {
    #[inline]
    pub unsafe fn take(&mut self) -> bool {
        xBinarySemaphore_take(self)
    }
    #[inline]
    pub unsafe fn tryTake(&mut self) -> bool {
        xBinarySemaphore_tryTake(self)
    }
    #[inline]
    pub unsafe fn take1(&mut self, timeoutMs: ::std::os::raw::c_int) -> bool {
        xBinarySemaphore_take1(self, timeoutMs)
    }
    #[inline]
    pub unsafe fn give(&mut self) -> bool {
        xBinarySemaphore_give(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xBinarySemaphore_xBinarySemaphore(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMutex {
    pub _handle: SemaphoreHandle_t,
}
extern "C" {
    #[link_name = "\u{1}_ZN6xMutex4lockEv"]
    pub fn xMutex_lock(this: *mut xMutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6xMutex6unlockEv"]
    pub fn xMutex_unlock(this: *mut xMutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN6xMutexC1Ev"]
    pub fn xMutex_xMutex(this: *mut xMutex);
}
impl xMutex {
    #[inline]
    pub unsafe fn lock(&mut self) -> bool {
        xMutex_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) -> bool {
        xMutex_unlock(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        xMutex_xMutex(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_Z17lnInitSystemClockv"]
    pub fn lnInitSystemClock();
}
pub const Peripherals_pNONE: Peripherals = 0;
pub const Peripherals_pSPI0: Peripherals = 1;
pub const Peripherals_pSPI1: Peripherals = 2;
pub const Peripherals_pSPI2: Peripherals = 3;
pub const Peripherals_pUART0: Peripherals = 4;
pub const Peripherals_pUART1: Peripherals = 5;
pub const Peripherals_pUART2: Peripherals = 6;
pub const Peripherals_pUART3: Peripherals = 7;
pub const Peripherals_pUART4: Peripherals = 8;
pub const Peripherals_pI2C0: Peripherals = 9;
pub const Peripherals_pI2C1: Peripherals = 10;
pub const Peripherals_pCAN0: Peripherals = 11;
pub const Peripherals_pCAN1: Peripherals = 12;
pub const Peripherals_pDAC: Peripherals = 13;
pub const Peripherals_pPMU: Peripherals = 14;
pub const Peripherals_pBKPI: Peripherals = 15;
pub const Peripherals_pWWDGT: Peripherals = 16;
pub const Peripherals_pTIMER0: Peripherals = 17;
pub const Peripherals_pTIMER1: Peripherals = 18;
pub const Peripherals_pTIMER2: Peripherals = 19;
pub const Peripherals_pTIMER3: Peripherals = 20;
pub const Peripherals_pTIMER4: Peripherals = 21;
pub const Peripherals_pTIMER5: Peripherals = 22;
pub const Peripherals_pTIMER6: Peripherals = 23;
pub const Peripherals_pADC0: Peripherals = 24;
pub const Peripherals_pADC1: Peripherals = 25;
pub const Peripherals_pGPIOA: Peripherals = 26;
pub const Peripherals_pGPIOB: Peripherals = 27;
pub const Peripherals_pGPIOC: Peripherals = 28;
pub const Peripherals_pGPIOD: Peripherals = 29;
pub const Peripherals_pGPIOE: Peripherals = 30;
pub const Peripherals_pAF: Peripherals = 31;
pub const Peripherals_pDMA0: Peripherals = 32;
pub const Peripherals_pDMA1: Peripherals = 33;
pub const Peripherals_pUSB: Peripherals = 34;
pub type Peripherals = ::std::os::raw::c_uint;
pub const lnADC_DIVIDER_lnADC_CLOCK_DIV_BY_2: lnADC_DIVIDER = 0;
pub const lnADC_DIVIDER_lnADC_CLOCK_DIV_BY_4: lnADC_DIVIDER = 1;
pub const lnADC_DIVIDER_lnADC_CLOCK_DIV_BY_6: lnADC_DIVIDER = 2;
pub const lnADC_DIVIDER_lnADC_CLOCK_DIV_BY_8: lnADC_DIVIDER = 3;
pub const lnADC_DIVIDER_lnADC_CLOCK_DIV_BY_12: lnADC_DIVIDER = 5;
pub const lnADC_DIVIDER_lnADC_CLOCK_DIV_BY_16: lnADC_DIVIDER = 7;
pub type lnADC_DIVIDER = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_ZN13lnPeripherals5resetE11Peripherals"]
    pub fn lnPeripherals_reset(periph: Peripherals);
}
extern "C" {
    #[link_name = "\u{1}_ZN13lnPeripherals6enableE11Peripherals"]
    pub fn lnPeripherals_enable(periph: Peripherals);
}
extern "C" {
    #[link_name = "\u{1}_ZN13lnPeripherals7disableE11Peripherals"]
    pub fn lnPeripherals_disable(periph: Peripherals);
}
extern "C" {
    #[link_name = "\u{1}_ZN13lnPeripherals8getClockE11Peripherals"]
    pub fn lnPeripherals_getClock(periph: Peripherals) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN13lnPeripherals13setAdcDividerE13lnADC_DIVIDER"]
    pub fn lnPeripherals_setAdcDivider(divider: lnADC_DIVIDER);
}
pub const LnIRQ_LN_IRQ_MSIP: LnIRQ = -13;
pub const LnIRQ_LN_IRQ_NONE: LnIRQ = -13;
pub const LnIRQ_LN_IRQ_RESET: LnIRQ = -12;
pub const LnIRQ_LN_IRQ_NMI: LnIRQ = -11;
pub const LnIRQ_LN_IRQ_HARDFAULT: LnIRQ = -10;
pub const LnIRQ_LN_IRQ_MEMMANAGE: LnIRQ = -9;
pub const LnIRQ_LN_IRQ_BUSFAULT: LnIRQ = -8;
pub const LnIRQ_LN_IRQ_USAGEFAULT: LnIRQ = -7;
pub const LnIRQ_LN_IRQ_RESERVED: LnIRQ = -6;
pub const LnIRQ_LN_IRQ_SVCALL: LnIRQ = -5;
pub const LnIRQ_LN_IRQ_DEBUGMON: LnIRQ = -4;
pub const LnIRQ_LN_IRQ_RESERVED2: LnIRQ = -3;
pub const LnIRQ_LN_IRQ_PENDSV: LnIRQ = -2;
pub const LnIRQ_LN_IRQ_SYSTICK: LnIRQ = -1;
pub const LnIRQ_LN_IRQ_WWDG: LnIRQ = 0;
pub const LnIRQ_LN_IRQ_LVD: LnIRQ = 1;
pub const LnIRQ_LN_IRQ_TAMPER: LnIRQ = 2;
pub const LnIRQ_LN_IRQ_RTC: LnIRQ = 3;
pub const LnIRQ_LN_IRQ_FMC: LnIRQ = 4;
pub const LnIRQ_LN_IRQ_RCU_RCC: LnIRQ = 5;
pub const LnIRQ_LN_IRQ_EXTI0: LnIRQ = 6;
pub const LnIRQ_LN_IRQ_EXTI1: LnIRQ = 7;
pub const LnIRQ_LN_IRQ_EXTI2: LnIRQ = 8;
pub const LnIRQ_LN_IRQ_EXTI3: LnIRQ = 9;
pub const LnIRQ_LN_IRQ_EXTI4: LnIRQ = 10;
pub const LnIRQ_LN_IRQ_DMA0_Channel0: LnIRQ = 11;
pub const LnIRQ_LN_IRQ_DMA0_Channel1: LnIRQ = 12;
pub const LnIRQ_LN_IRQ_DMA0_Channel2: LnIRQ = 13;
pub const LnIRQ_LN_IRQ_DMA0_Channel3: LnIRQ = 14;
pub const LnIRQ_LN_IRQ_DMA0_Channel4: LnIRQ = 15;
pub const LnIRQ_LN_IRQ_DMA0_Channel5: LnIRQ = 16;
pub const LnIRQ_LN_IRQ_DMA0_Channel6: LnIRQ = 17;
pub const LnIRQ_LN_IRQ_ADC0_1: LnIRQ = 18;
pub const LnIRQ_LN_IRQ_USB_HP_CAN_TX: LnIRQ = 19;
pub const LnIRQ_LN_IRQ_USB_LP_CAN_RX0: LnIRQ = 20;
pub const LnIRQ_LN_IRQ_CAN_RX1: LnIRQ = 21;
pub const LnIRQ_LN_IRQ_CAN_SCE: LnIRQ = 22;
pub const LnIRQ_LN_IRQ_EXTI5_9: LnIRQ = 23;
pub const LnIRQ_LN_IRQ_TIMER0_BRK: LnIRQ = 24;
pub const LnIRQ_LN_IRQ_TIMER0_UP: LnIRQ = 25;
pub const LnIRQ_LN_IRQ_TIMER0_TRG_CMT: LnIRQ = 26;
pub const LnIRQ_LN_IRQ_TIMER0_Channel: LnIRQ = 27;
pub const LnIRQ_LN_IRQ_TIMER1: LnIRQ = 28;
pub const LnIRQ_LN_IRQ_TIMER2: LnIRQ = 29;
pub const LnIRQ_LN_IRQ_TIMER3: LnIRQ = 30;
pub const LnIRQ_LN_IRQ_I2C0_EV: LnIRQ = 31;
pub const LnIRQ_LN_IRQ_I2C0_ER: LnIRQ = 32;
pub const LnIRQ_LN_IRQ_I2C1_EV: LnIRQ = 33;
pub const LnIRQ_LN_IRQ_I2C1_ER: LnIRQ = 34;
pub const LnIRQ_LN_IRQ_SPI0: LnIRQ = 35;
pub const LnIRQ_LN_IRQ_SPI1: LnIRQ = 36;
pub const LnIRQ_LN_IRQ_USART0: LnIRQ = 37;
pub const LnIRQ_LN_IRQ_USART1: LnIRQ = 38;
pub const LnIRQ_LN_IRQ_USART2: LnIRQ = 39;
pub const LnIRQ_LN_IRQ_EXTI10_15: LnIRQ = 40;
pub const LnIRQ_LN_IRQ_RTCALARM: LnIRQ = 41;
pub const LnIRQ_LN_IRQ_USBWAKEUP: LnIRQ = 42;
pub const LnIRQ_LN_IRQ_TIMER7_BRK_TIMER12: LnIRQ = 43;
pub const LnIRQ_LN_IRQ_TIMER7_UP_TIMER13: LnIRQ = 44;
pub const LnIRQ_LN_IRQ_TIMER7_TRG_COM_TIMER14: LnIRQ = 45;
pub const LnIRQ_LN_IRQ_TIMER7_CC: LnIRQ = 46;
pub const LnIRQ_LN_IRQ_ADC2: LnIRQ = 47;
pub const LnIRQ_LN_IRQ_FSMC: LnIRQ = 48;
pub const LnIRQ_LN_IRQ_SDIO: LnIRQ = 49;
pub const LnIRQ_LN_IRQ_TIMER4: LnIRQ = 50;
pub const LnIRQ_LN_IRQ_SPI2: LnIRQ = 51;
pub const LnIRQ_LN_IRQ_UART3: LnIRQ = 52;
pub const LnIRQ_LN_IRQ_UART4: LnIRQ = 53;
pub const LnIRQ_LN_IRQ_TIMER5: LnIRQ = 54;
pub const LnIRQ_LN_IRQ_TIMER6: LnIRQ = 55;
pub const LnIRQ_LN_IRQ_DMA1_Channel0: LnIRQ = 56;
pub const LnIRQ_LN_IRQ_DMA1_Channel1: LnIRQ = 57;
pub const LnIRQ_LN_IRQ_DMA1_Channel2: LnIRQ = 58;
pub const LnIRQ_LN_IRQ_DMA1_Channel3: LnIRQ = 59;
pub const LnIRQ_LN_IRQ_DMA1_Channel4: LnIRQ = 60;
pub const LnIRQ_LN_IRQ_ARM_LAST: LnIRQ = 61;
pub type LnIRQ = ::std::os::raw::c_int;
pub type lnInterruptHandler = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}_Z17lnEnableInterruptRK5LnIRQ"]
    pub fn lnEnableInterrupt(irq: *const LnIRQ);
}
extern "C" {
    #[link_name = "\u{1}_Z18lnDisableInterruptRK5LnIRQ"]
    pub fn lnDisableInterrupt(irq: *const LnIRQ);
}
extern "C" {
    #[link_name = "\u{1}_Z21lnSetInterruptHandlerRK5LnIRQPFvvE"]
    pub fn lnSetInterruptHandler(irq: *const LnIRQ, handler: lnInterruptHandler);
}
extern "C" {
    #[link_name = "\u{1}_Z16lnIrqSetPriorityRK5LnIRQi"]
    pub fn lnIrqSetPriority(irq: *const LnIRQ, prio: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_Z7lnGetUsv"]
    pub fn lnGetUs() -> u32;
}
extern "C" {
    #[link_name = "\u{1}_Z9lnGetUs64v"]
    pub fn lnGetUs64() -> u64;
}
extern "C" {
    #[link_name = "\u{1}_Z9lnDelayUsi"]
    pub fn lnDelayUs(wait: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_Z7lnGetMsv"]
    pub fn lnGetMs() -> u32;
}
#[doc = " \\brief If you do a dma transfer"]
#[doc = ""]
#[doc = " call beginTransfer() from the task, that will lock the DMA for you"]
#[doc = " call doMemoryToPeripheralTransferFromInterrupt() from the task or the interrupt"]
#[doc = " call endTransfer() when you will not use the dma any longer until the next begin()"]
#[doc = " If you are starting a DMA from interrupt, you should do the begin() out of the interrupt and the end when that transfer is 100% done"]
#[doc = " If you are starting a DMA from a task you can do begin()/ doMemoryToPeripheral/end() as many times as you want, that will leave"]
#[doc = " the dma channel usable by another peripheral in between at the expense of more overhead"]
#[doc = ""]
#[doc = ""]
#[repr(C)]
#[derive(Debug)]
pub struct lnDMA {
    pub _dma: u32,
    pub _channelInt: ::std::os::raw::c_int,
    pub _dmaInt: ::std::os::raw::c_int,
    pub _type: lnDMA_DmaTransferType,
    pub _irq: LnIRQ,
    pub _cb: lnDMA_doneCallback,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _control: u32,
    pub _priority: u32,
    pub _sourceWidth: ::std::os::raw::c_int,
    pub _targetWidth: ::std::os::raw::c_int,
}
pub const lnDMA_DmaInterruptType_DMA_INTERRUPT_HALF: lnDMA_DmaInterruptType = 0;
pub const lnDMA_DmaInterruptType_DMA_INTERRUPT_FULL: lnDMA_DmaInterruptType = 1;
pub type lnDMA_DmaInterruptType = ::std::os::raw::c_uint;
pub type lnDMA_doneCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: lnDMA_DmaInterruptType),
>;
pub const lnDMA_DmaTransferType_DMA_MEMORY_TO_PERIPH: lnDMA_DmaTransferType = 0;
pub const lnDMA_DmaTransferType_DMA_PERIPH_TO_MEMORY: lnDMA_DmaTransferType = 1;
pub type lnDMA_DmaTransferType = ::std::os::raw::c_uint;
pub const lnDMA_DmaPriority_DMA_PRIORITY_LOW: lnDMA_DmaPriority = 0;
pub const lnDMA_DmaPriority_DMA_PRIORITY_NORMAL: lnDMA_DmaPriority = 1;
pub const lnDMA_DmaPriority_DMA_PRIORITY_HIGH: lnDMA_DmaPriority = 2;
pub const lnDMA_DmaPriority_DMA_PRIORITY_ULTRA_HIGH: lnDMA_DmaPriority = 3;
pub type lnDMA_DmaPriority = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA14attachCallbackEPFvPvNS_16DmaInterruptTypeEES0_"]
    pub fn lnDMA_attachCallback(
        this: *mut lnDMA,
        cb: lnDMA_doneCallback,
        cookie: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA14detachCallbackEv"]
    pub fn lnDMA_detachCallback(this: *mut lnDMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA34doMemoryToPeripheralTransferNoLockEiPKtS1_bbb"]
    pub fn lnDMA_doMemoryToPeripheralTransferNoLock(
        this: *mut lnDMA,
        count: ::std::os::raw::c_int,
        source: *const u16,
        target: *const u16,
        repeat: bool,
        circularMode: bool,
        bothInterrutps: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA34doPeripheralToMemoryTransferNoLockEiPKtS1_bb"]
    pub fn lnDMA_doPeripheralToMemoryTransferNoLock(
        this: *mut lnDMA,
        count: ::std::os::raw::c_int,
        target: *const u16,
        source: *const u16,
        circularMode: bool,
        bothInterrutps: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA16setInterruptMaskEbb"]
    pub fn lnDMA_setInterruptMask(this: *mut lnDMA, full: bool, half: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA11setPriorityENS_11DmaPriorityE"]
    pub fn lnDMA_setPriority(this: *mut lnDMA, prio: lnDMA_DmaPriority);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA13beginTransferEv"]
    pub fn lnDMA_beginTransfer(this: *mut lnDMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA15getCurrentCountEv"]
    pub fn lnDMA_getCurrentCount(this: *mut lnDMA) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA11endTransferEv"]
    pub fn lnDMA_endTransfer(this: *mut lnDMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA14cancelTransferEv"]
    pub fn lnDMA_cancelTransfer(this: *mut lnDMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA11setWordSizeEii"]
    pub fn lnDMA_setWordSize(
        this: *mut lnDMA,
        sourceWordSize: ::std::os::raw::c_int,
        targetWordSize: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA14invokeCallbackEv"]
    pub fn lnDMA_invokeCallback(this: *mut lnDMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA5pauseEv"]
    pub fn lnDMA_pause(this: *mut lnDMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA6resumeEv"]
    pub fn lnDMA_resume(this: *mut lnDMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMAC1ENS_15DmaTransferTypeEiiii"]
    pub fn lnDMA_lnDMA(
        this: *mut lnDMA,
        type_: lnDMA_DmaTransferType,
        dmaEngine: ::std::os::raw::c_int,
        dmaChannel: ::std::os::raw::c_int,
        sourceWith: ::std::os::raw::c_int,
        targetWidth: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMAD1Ev"]
    pub fn lnDMA_lnDMA_destructor(this: *mut lnDMA);
}
impl lnDMA {
    #[inline]
    pub unsafe fn attachCallback(
        &mut self,
        cb: lnDMA_doneCallback,
        cookie: *mut ::std::os::raw::c_void,
    ) {
        lnDMA_attachCallback(self, cb, cookie)
    }
    #[inline]
    pub unsafe fn detachCallback(&mut self) {
        lnDMA_detachCallback(self)
    }
    #[inline]
    pub unsafe fn doMemoryToPeripheralTransferNoLock(
        &mut self,
        count: ::std::os::raw::c_int,
        source: *const u16,
        target: *const u16,
        repeat: bool,
        circularMode: bool,
        bothInterrutps: bool,
    ) -> bool {
        lnDMA_doMemoryToPeripheralTransferNoLock(
            self,
            count,
            source,
            target,
            repeat,
            circularMode,
            bothInterrutps,
        )
    }
    #[inline]
    pub unsafe fn doPeripheralToMemoryTransferNoLock(
        &mut self,
        count: ::std::os::raw::c_int,
        target: *const u16,
        source: *const u16,
        circularMode: bool,
        bothInterrutps: bool,
    ) -> bool {
        lnDMA_doPeripheralToMemoryTransferNoLock(
            self,
            count,
            target,
            source,
            circularMode,
            bothInterrutps,
        )
    }
    #[inline]
    pub unsafe fn setInterruptMask(&mut self, full: bool, half: bool) -> bool {
        lnDMA_setInterruptMask(self, full, half)
    }
    #[inline]
    pub unsafe fn setPriority(&mut self, prio: lnDMA_DmaPriority) {
        lnDMA_setPriority(self, prio)
    }
    #[inline]
    pub unsafe fn beginTransfer(&mut self) {
        lnDMA_beginTransfer(self)
    }
    #[inline]
    pub unsafe fn getCurrentCount(&mut self) -> u32 {
        lnDMA_getCurrentCount(self)
    }
    #[inline]
    pub unsafe fn endTransfer(&mut self) {
        lnDMA_endTransfer(self)
    }
    #[inline]
    pub unsafe fn cancelTransfer(&mut self) {
        lnDMA_cancelTransfer(self)
    }
    #[inline]
    pub unsafe fn setWordSize(
        &mut self,
        sourceWordSize: ::std::os::raw::c_int,
        targetWordSize: ::std::os::raw::c_int,
    ) {
        lnDMA_setWordSize(self, sourceWordSize, targetWordSize)
    }
    #[inline]
    pub unsafe fn invokeCallback(&mut self) {
        lnDMA_invokeCallback(self)
    }
    #[inline]
    pub unsafe fn pause(&mut self) {
        lnDMA_pause(self)
    }
    #[inline]
    pub unsafe fn resume(&mut self) {
        lnDMA_resume(self)
    }
    #[inline]
    pub unsafe fn new(
        type_: lnDMA_DmaTransferType,
        dmaEngine: ::std::os::raw::c_int,
        dmaChannel: ::std::os::raw::c_int,
        sourceWith: ::std::os::raw::c_int,
        targetWidth: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        lnDMA_lnDMA(
            __bindgen_tmp.as_mut_ptr(),
            type_,
            dmaEngine,
            dmaChannel,
            sourceWith,
            targetWidth,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        lnDMA_lnDMA_destructor(self)
    }
}
pub const lnADC_CYCLES_LN_ADC_SMPT_1_5: lnADC_CYCLES = 0;
pub const lnADC_CYCLES_LN_ADC_SMPT_7_5: lnADC_CYCLES = 1;
pub const lnADC_CYCLES_LN_ADC_SMPT_13_5: lnADC_CYCLES = 2;
pub const lnADC_CYCLES_LN_ADC_SMPT_28_5: lnADC_CYCLES = 3;
pub const lnADC_CYCLES_LN_ADC_SMPT_41_5: lnADC_CYCLES = 4;
pub const lnADC_CYCLES_LN_ADC_SMPT_55_5: lnADC_CYCLES = 5;
pub const lnADC_CYCLES_LN_ADC_SMPT_71_5: lnADC_CYCLES = 6;
pub const lnADC_CYCLES_LN_ADC_SMPT_239_5: lnADC_CYCLES = 7;
pub type lnADC_CYCLES = ::std::os::raw::c_uint;
#[repr(C)]
pub struct lnBaseAdc__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct lnBaseAdc {
    pub vtable_: *const lnBaseAdc__bindgen_vtable,
    pub _instance: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN9lnBaseAdc7getVrefEv"]
    pub fn lnBaseAdc_getVref(this: *mut lnBaseAdc) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN9lnBaseAdc6getVccEv"]
    pub fn lnBaseAdc_getVcc() -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN9lnBaseAdc7setSmptE12lnADC_CYCLES"]
    pub fn lnBaseAdc_setSmpt(this: *mut lnBaseAdc, cycles: lnADC_CYCLES);
}
extern "C" {
    #[link_name = "\u{1}_ZN9lnBaseAdc7readVccEv"]
    pub fn lnBaseAdc_readVcc(this: *mut lnBaseAdc);
}
extern "C" {
    #[link_name = "\u{1}_ZN9lnBaseAdc10adcChannelEi"]
    pub fn lnBaseAdc_adcChannel(pin: lnPin) -> ::std::os::raw::c_int;
}
impl lnBaseAdc {
    #[inline]
    pub unsafe fn getVref(&mut self) -> ::std::os::raw::c_int {
        lnBaseAdc_getVref(self)
    }
    #[inline]
    pub unsafe fn getVcc() -> f32 {
        lnBaseAdc_getVcc()
    }
    #[inline]
    pub unsafe fn setSmpt(&mut self, cycles: lnADC_CYCLES) {
        lnBaseAdc_setSmpt(self, cycles)
    }
    #[inline]
    pub unsafe fn readVcc(&mut self) {
        lnBaseAdc_readVcc(self)
    }
    #[inline]
    pub unsafe fn adcChannel(pin: lnPin) -> ::std::os::raw::c_int {
        lnBaseAdc_adcChannel(pin)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN9lnBaseAdc5setupEv"]
    pub fn lnBaseAdc_setup(this: *mut ::std::os::raw::c_void);
}
#[doc = " @param instance"]
#[repr(C)]
#[derive(Debug)]
pub struct lnSimpleADC {
    pub _base: lnBaseAdc,
    pub _pin: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADC3pinEv"]
    pub fn lnSimpleADC_pin(this: *mut lnSimpleADC) -> lnPin;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADC6setPinEi"]
    pub fn lnSimpleADC_setPin(this: *mut lnSimpleADC, pin: lnPin) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADC10simpleReadEv"]
    pub fn lnSimpleADC_simpleRead(this: *mut lnSimpleADC) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADC16pollingMultiReadEiPiPt"]
    pub fn lnSimpleADC_pollingMultiRead(
        this: *mut lnSimpleADC,
        nbPins: ::std::os::raw::c_int,
        pins: *mut lnPin,
        output: *mut u16,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADC7getVrefEv"]
    pub fn lnSimpleADC_getVref(this: *mut lnSimpleADC) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADC6getVccEv"]
    pub fn lnSimpleADC_getVcc() -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADC7readVccEv"]
    pub fn lnSimpleADC_readVcc(this: *mut lnSimpleADC);
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADCC1Eii"]
    pub fn lnSimpleADC_lnSimpleADC(
        this: *mut lnSimpleADC,
        instance: ::std::os::raw::c_int,
        pin: lnPin,
    );
}
impl lnSimpleADC {
    #[inline]
    pub unsafe fn pin(&mut self) -> lnPin {
        lnSimpleADC_pin(self)
    }
    #[inline]
    pub unsafe fn setPin(&mut self, pin: lnPin) -> bool {
        lnSimpleADC_setPin(self, pin)
    }
    #[inline]
    pub unsafe fn simpleRead(&mut self) -> ::std::os::raw::c_int {
        lnSimpleADC_simpleRead(self)
    }
    #[inline]
    pub unsafe fn pollingMultiRead(
        &mut self,
        nbPins: ::std::os::raw::c_int,
        pins: *mut lnPin,
        output: *mut u16,
    ) -> bool {
        lnSimpleADC_pollingMultiRead(self, nbPins, pins, output)
    }
    #[inline]
    pub unsafe fn getVref(&mut self) -> ::std::os::raw::c_int {
        lnSimpleADC_getVref(self)
    }
    #[inline]
    pub unsafe fn getVcc() -> f32 {
        lnSimpleADC_getVcc()
    }
    #[inline]
    pub unsafe fn readVcc(&mut self) {
        lnSimpleADC_readVcc(self)
    }
    #[inline]
    pub unsafe fn new(instance: ::std::os::raw::c_int, pin: lnPin) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        lnSimpleADC_lnSimpleADC(__bindgen_tmp.as_mut_ptr(), instance, pin);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADCD1Ev"]
    pub fn lnSimpleADC_lnSimpleADC_destructor(this: *mut lnSimpleADC);
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADC5setupEv"]
    pub fn lnSimpleADC_setup(this: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug)]
pub struct lnTimingAdc {
    pub _base: lnBaseAdc,
    pub _timer: ::std::os::raw::c_int,
    pub _channel: ::std::os::raw::c_int,
    pub _fq: ::std::os::raw::c_int,
    pub _dma: lnDMA,
    pub _dmaSem: xBinarySemaphore,
    pub _adcTimer: *mut lnAdcTimer,
    pub _nbPins: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnTimingAdc9setSourceEiiiiPi"]
    pub fn lnTimingAdc_setSource(
        this: *mut lnTimingAdc,
        timer: ::std::os::raw::c_int,
        channel: ::std::os::raw::c_int,
        fq: ::std::os::raw::c_int,
        nbPins: ::std::os::raw::c_int,
        pins: *mut lnPin,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnTimingAdc9multiReadEiPt"]
    pub fn lnTimingAdc_multiRead(
        this: *mut lnTimingAdc,
        nbSamplePerChannel: ::std::os::raw::c_int,
        output: *mut u16,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnTimingAdc8dmaDone_EPvN5lnDMA16DmaInterruptTypeE"]
    pub fn lnTimingAdc_dmaDone_(foo: *mut ::std::os::raw::c_void, typ: lnDMA_DmaInterruptType);
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnTimingAdc7dmaDoneEv"]
    pub fn lnTimingAdc_dmaDone(this: *mut lnTimingAdc);
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnTimingAdcC1Ei"]
    pub fn lnTimingAdc_lnTimingAdc(this: *mut lnTimingAdc, instance: ::std::os::raw::c_int);
}
impl lnTimingAdc {
    #[inline]
    pub unsafe fn setSource(
        &mut self,
        timer: ::std::os::raw::c_int,
        channel: ::std::os::raw::c_int,
        fq: ::std::os::raw::c_int,
        nbPins: ::std::os::raw::c_int,
        pins: *mut lnPin,
    ) -> bool {
        lnTimingAdc_setSource(self, timer, channel, fq, nbPins, pins)
    }
    #[inline]
    pub unsafe fn multiRead(
        &mut self,
        nbSamplePerChannel: ::std::os::raw::c_int,
        output: *mut u16,
    ) -> bool {
        lnTimingAdc_multiRead(self, nbSamplePerChannel, output)
    }
    #[inline]
    pub unsafe fn dmaDone_(foo: *mut ::std::os::raw::c_void, typ: lnDMA_DmaInterruptType) {
        lnTimingAdc_dmaDone_(foo, typ)
    }
    #[inline]
    pub unsafe fn dmaDone(&mut self) {
        lnTimingAdc_dmaDone(self)
    }
    #[inline]
    pub unsafe fn new(instance: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        lnTimingAdc_lnTimingAdc(__bindgen_tmp.as_mut_ptr(), instance);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnTimingAdcD1Ev"]
    pub fn lnTimingAdc_lnTimingAdc_destructor(this: *mut lnTimingAdc);
}
pub type lnBasicTimerIrq =
    ::std::option::Option<unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void)>;
#[repr(C)]
pub struct lnBasicTimer__bindgen_vtable(::std::os::raw::c_void);
#[doc = " \\brief Careful all the channels of a given timer share the same frequency!"]
#[doc = " Max frequency is around 100 kHz in PWM mode !"]
#[doc = ""]
#[doc = ""]
#[doc = " In all mode , after setup the channel is disabled"]
#[doc = " You have to explicitely call timer->enable()"]
#[doc = ""]
#[doc = " @param timer"]
#[doc = " @param channel"]
#[repr(C)]
#[derive(Debug)]
pub struct lnBasicTimer {
    pub vtable_: *const lnBasicTimer__bindgen_vtable,
    pub _timer: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnBasicTimer17setTimerFrequencyEi"]
    pub fn lnBasicTimer_setTimerFrequency(this: *mut lnBasicTimer, fqInHz: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnBasicTimer17setTimerFrequencyEii"]
    pub fn lnBasicTimer_setTimerFrequency1(
        this: *mut lnBasicTimer,
        prediv: ::std::os::raw::c_int,
        reload: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnBasicTimer17getTimerFrequencyEv"]
    pub fn lnBasicTimer_getTimerFrequency(this: *mut lnBasicTimer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnBasicTimer7disableEv"]
    pub fn lnBasicTimer_disable(this: *mut lnBasicTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnBasicTimer6enableEv"]
    pub fn lnBasicTimer_enable(this: *mut lnBasicTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnBasicTimerC1Ei"]
    pub fn lnBasicTimer_lnBasicTimer(this: *mut lnBasicTimer, timer: ::std::os::raw::c_int);
}
impl lnBasicTimer {
    #[inline]
    pub unsafe fn setTimerFrequency(&mut self, fqInHz: ::std::os::raw::c_int) {
        lnBasicTimer_setTimerFrequency(self, fqInHz)
    }
    #[inline]
    pub unsafe fn setTimerFrequency1(
        &mut self,
        prediv: ::std::os::raw::c_int,
        reload: ::std::os::raw::c_int,
    ) {
        lnBasicTimer_setTimerFrequency1(self, prediv, reload)
    }
    #[inline]
    pub unsafe fn getTimerFrequency(&mut self) -> ::std::os::raw::c_int {
        lnBasicTimer_getTimerFrequency(self)
    }
    #[inline]
    pub unsafe fn disable(&mut self) {
        lnBasicTimer_disable(self)
    }
    #[inline]
    pub unsafe fn enable(&mut self) {
        lnBasicTimer_enable(self)
    }
    #[inline]
    pub unsafe fn new(timer: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        lnBasicTimer_lnBasicTimer(__bindgen_tmp.as_mut_ptr(), timer);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnBasicTimerD1Ev"]
    pub fn lnBasicTimer_lnBasicTimer_destructor(this: *mut lnBasicTimer);
}
#[doc = " @param timer"]
#[doc = " @return"]
#[repr(C)]
#[derive(Debug)]
pub struct lnBasicDelayTimer {
    pub _base: lnBasicTimer,
    pub _handler: lnBasicTimerIrq,
    pub _cookie: *mut ::std::os::raw::c_void,
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBasicDelayTimer3armEi"]
    pub fn lnBasicDelayTimer_arm(this: *mut lnBasicDelayTimer, delayUs: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBasicDelayTimer12setInterruptEPFvPvES0_"]
    pub fn lnBasicDelayTimer_setInterrupt(
        this: *mut lnBasicDelayTimer,
        handler: lnBasicTimerIrq,
        cookie: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBasicDelayTimer16interruptHandlerEi"]
    pub fn lnBasicDelayTimer_interruptHandler(timer: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBasicDelayTimer3irqEv"]
    pub fn lnBasicDelayTimer_irq(this: *mut lnBasicDelayTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBasicDelayTimer15enableInterruptEv"]
    pub fn lnBasicDelayTimer_enableInterrupt(this: *mut lnBasicDelayTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBasicDelayTimer16disableInterruptEv"]
    pub fn lnBasicDelayTimer_disableInterrupt(this: *mut lnBasicDelayTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBasicDelayTimerC1Ei"]
    pub fn lnBasicDelayTimer_lnBasicDelayTimer(
        this: *mut lnBasicDelayTimer,
        timer: ::std::os::raw::c_int,
    );
}
impl lnBasicDelayTimer {
    #[inline]
    pub unsafe fn arm(&mut self, delayUs: ::std::os::raw::c_int) {
        lnBasicDelayTimer_arm(self, delayUs)
    }
    #[inline]
    pub unsafe fn setInterrupt(
        &mut self,
        handler: lnBasicTimerIrq,
        cookie: *mut ::std::os::raw::c_void,
    ) {
        lnBasicDelayTimer_setInterrupt(self, handler, cookie)
    }
    #[inline]
    pub unsafe fn interruptHandler(timer: ::std::os::raw::c_int) {
        lnBasicDelayTimer_interruptHandler(timer)
    }
    #[inline]
    pub unsafe fn irq(&mut self) {
        lnBasicDelayTimer_irq(self)
    }
    #[inline]
    pub unsafe fn enableInterrupt(&mut self) {
        lnBasicDelayTimer_enableInterrupt(self)
    }
    #[inline]
    pub unsafe fn disableInterrupt(&mut self) {
        lnBasicDelayTimer_disableInterrupt(self)
    }
    #[inline]
    pub unsafe fn new(timer: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        lnBasicDelayTimer_lnBasicDelayTimer(__bindgen_tmp.as_mut_ptr(), timer);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBasicDelayTimerD1Ev"]
    pub fn lnBasicDelayTimer_lnBasicDelayTimer_destructor(this: *mut lnBasicDelayTimer);
}
pub const lnCpuID_LN_VENDOR_LN_MCU_STM32: lnCpuID_LN_VENDOR = 0;
pub const lnCpuID_LN_VENDOR_LN_MCU_GD32: lnCpuID_LN_VENDOR = 1;
pub type lnCpuID_LN_VENDOR = ::std::os::raw::c_uint;
pub const lnCpuID_LN_MCU_LN_MCU_ARM_F3: lnCpuID_LN_MCU = 0;
pub const lnCpuID_LN_MCU_LN_MCU_ARM_F4: lnCpuID_LN_MCU = 1;
pub const lnCpuID_LN_MCU_LN_MCU_RISCV: lnCpuID_LN_MCU = 2;
pub type lnCpuID_LN_MCU = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_ZN7lnCpuID8identifyEv"]
    pub fn lnCpuID_identify();
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnCpuID6vendorEv"]
    pub fn lnCpuID_vendor() -> lnCpuID_LN_VENDOR;
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnCpuID3mcuEv"]
    pub fn lnCpuID_mcu() -> lnCpuID_LN_MCU;
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnCpuID11mcuAsStringEv"]
    pub fn lnCpuID_mcuAsString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnCpuID9flashSizeEv"]
    pub fn lnCpuID_flashSize() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnCpuID7ramSizeEv"]
    pub fn lnCpuID_ramSize() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnCpuID10idAsStringEv"]
    pub fn lnCpuID_idAsString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnCpuID10clockSpeedEv"]
    pub fn lnCpuID_clockSpeed() -> ::std::os::raw::c_int;
}
#[repr(C)]
pub struct lnDAC__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @param instance"]
#[repr(C)]
#[derive(Debug)]
pub struct lnDAC {
    pub vtable_: *const lnDAC__bindgen_vtable,
    pub _instance: ::std::os::raw::c_int,
    pub _dma: lnDMA,
    pub _timer: *mut lnBasicTimer,
    pub _dmaSem: xBinarySemaphore,
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC3pinEv"]
    pub fn lnDAC_pin(this: *mut lnDAC) -> lnPin;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC6enableEv"]
    pub fn lnDAC_enable(this: *mut lnDAC);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC7disableEv"]
    pub fn lnDAC_disable(this: *mut lnDAC);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC10simpleModeEv"]
    pub fn lnDAC_simpleMode(this: *mut lnDAC);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC8setValueEi"]
    pub fn lnDAC_setValue(this: *mut lnDAC, value: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC12startDmaModeEi"]
    pub fn lnDAC_startDmaMode(this: *mut lnDAC, fq: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC11stopDmaModeEv"]
    pub fn lnDAC_stopDmaMode(this: *mut lnDAC);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC15getDmaFrequencyEv"]
    pub fn lnDAC_getDmaFrequency(this: *mut lnDAC) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC8dmaWriteEiPtb"]
    pub fn lnDAC_dmaWrite(
        this: *mut lnDAC,
        nbn: ::std::os::raw::c_int,
        data: *mut u16,
        loop_: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC8dmaDone_EPvN5lnDMA16DmaInterruptTypeE"]
    pub fn lnDAC_dmaDone_(t: *mut ::std::os::raw::c_void, typ: lnDMA_DmaInterruptType);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC7dmaDoneEv"]
    pub fn lnDAC_dmaDone(this: *mut lnDAC);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC16dmaWriteInternalEiPtb"]
    pub fn lnDAC_dmaWriteInternal(
        this: *mut lnDAC,
        nb: ::std::os::raw::c_int,
        data: *mut u16,
        loop_: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDACC1Ei"]
    pub fn lnDAC_lnDAC(this: *mut lnDAC, instance: ::std::os::raw::c_int);
}
impl lnDAC {
    #[inline]
    pub unsafe fn pin(&mut self) -> lnPin {
        lnDAC_pin(self)
    }
    #[inline]
    pub unsafe fn enable(&mut self) {
        lnDAC_enable(self)
    }
    #[inline]
    pub unsafe fn disable(&mut self) {
        lnDAC_disable(self)
    }
    #[inline]
    pub unsafe fn simpleMode(&mut self) {
        lnDAC_simpleMode(self)
    }
    #[inline]
    pub unsafe fn setValue(&mut self, value: ::std::os::raw::c_int) {
        lnDAC_setValue(self, value)
    }
    #[inline]
    pub unsafe fn startDmaMode(&mut self, fq: ::std::os::raw::c_int) {
        lnDAC_startDmaMode(self, fq)
    }
    #[inline]
    pub unsafe fn stopDmaMode(&mut self) {
        lnDAC_stopDmaMode(self)
    }
    #[inline]
    pub unsafe fn getDmaFrequency(&mut self) -> ::std::os::raw::c_int {
        lnDAC_getDmaFrequency(self)
    }
    #[inline]
    pub unsafe fn dmaWrite(&mut self, nbn: ::std::os::raw::c_int, data: *mut u16, loop_: bool) {
        lnDAC_dmaWrite(self, nbn, data, loop_)
    }
    #[inline]
    pub unsafe fn dmaDone_(t: *mut ::std::os::raw::c_void, typ: lnDMA_DmaInterruptType) {
        lnDAC_dmaDone_(t, typ)
    }
    #[inline]
    pub unsafe fn dmaDone(&mut self) {
        lnDAC_dmaDone(self)
    }
    #[inline]
    pub unsafe fn dmaWriteInternal(
        &mut self,
        nb: ::std::os::raw::c_int,
        data: *mut u16,
        loop_: bool,
    ) {
        lnDAC_dmaWriteInternal(self, nb, data, loop_)
    }
    #[inline]
    pub unsafe fn new(instance: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        lnDAC_lnDAC(__bindgen_tmp.as_mut_ptr(), instance);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDACD1Ev"]
    pub fn lnDAC_lnDAC_destructor(this: *mut lnDAC);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnFMC5eraseEji"]
    pub fn lnFMC_erase(startAddress: u32, sizeInKBytes: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnFMC5writeEjPKhi"]
    pub fn lnFMC_write(
        startAddress: u32,
        data: *const u8,
        sizeInBytes: ::std::os::raw::c_int,
    ) -> bool;
}
#[repr(C)]
pub struct lnI2C__bindgen_vtable(::std::os::raw::c_void);
#[doc = " @param instance"]
#[doc = " @param speed"]
#[repr(C)]
#[derive(Debug)]
pub struct lnI2C {
    pub vtable_: *const lnI2C__bindgen_vtable,
    pub cookie: *mut ::std::os::raw::c_void,
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2C8setSpeedEi"]
    pub fn lnI2C_setSpeed(this: *mut lnI2C, speed: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2C10setAddressEi"]
    pub fn lnI2C_setAddress(this: *mut lnI2C, address: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2C5writeEiPh"]
    pub fn lnI2C_write(this: *mut lnI2C, n: ::std::os::raw::c_int, data: *mut u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2C4readEiPh"]
    pub fn lnI2C_read(this: *mut lnI2C, n: ::std::os::raw::c_int, data: *mut u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2C5writeEiiPh"]
    pub fn lnI2C_write1(
        this: *mut lnI2C,
        target: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        data: *mut u8,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2C10multiWriteEiiPiPPh"]
    pub fn lnI2C_multiWrite(
        this: *mut lnI2C,
        target: ::std::os::raw::c_int,
        nbSeqn: ::std::os::raw::c_int,
        seqLength: *mut ::std::os::raw::c_int,
        data: *mut *mut u8,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2C4readEiiPh"]
    pub fn lnI2C_read1(
        this: *mut lnI2C,
        target: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        data: *mut u8,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2C5beginEi"]
    pub fn lnI2C_begin(this: *mut lnI2C, target: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2CC1Eii"]
    pub fn lnI2C_lnI2C(
        this: *mut lnI2C,
        instance: ::std::os::raw::c_int,
        speed: ::std::os::raw::c_int,
    );
}
impl lnI2C {
    #[inline]
    pub unsafe fn setSpeed(&mut self, speed: ::std::os::raw::c_int) {
        lnI2C_setSpeed(self, speed)
    }
    #[inline]
    pub unsafe fn setAddress(&mut self, address: ::std::os::raw::c_int) {
        lnI2C_setAddress(self, address)
    }
    #[inline]
    pub unsafe fn write(&mut self, n: ::std::os::raw::c_int, data: *mut u8) -> bool {
        lnI2C_write(self, n, data)
    }
    #[inline]
    pub unsafe fn read(&mut self, n: ::std::os::raw::c_int, data: *mut u8) -> bool {
        lnI2C_read(self, n, data)
    }
    #[inline]
    pub unsafe fn write1(
        &mut self,
        target: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        data: *mut u8,
    ) -> bool {
        lnI2C_write1(self, target, n, data)
    }
    #[inline]
    pub unsafe fn multiWrite(
        &mut self,
        target: ::std::os::raw::c_int,
        nbSeqn: ::std::os::raw::c_int,
        seqLength: *mut ::std::os::raw::c_int,
        data: *mut *mut u8,
    ) -> bool {
        lnI2C_multiWrite(self, target, nbSeqn, seqLength, data)
    }
    #[inline]
    pub unsafe fn read1(
        &mut self,
        target: ::std::os::raw::c_int,
        n: ::std::os::raw::c_int,
        data: *mut u8,
    ) -> bool {
        lnI2C_read1(self, target, n, data)
    }
    #[inline]
    pub unsafe fn begin(&mut self, target: ::std::os::raw::c_int) -> bool {
        lnI2C_begin(self, target)
    }
    #[inline]
    pub unsafe fn new(instance: ::std::os::raw::c_int, speed: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        lnI2C_lnI2C(__bindgen_tmp.as_mut_ptr(), instance, speed);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2CD1Ev"]
    pub fn lnI2C_lnI2C_destructor(this: *mut lnI2C);
}
#[repr(C)]
#[derive(Debug)]
pub struct lnSerial {
    pub _instance: ::std::os::raw::c_int,
    pub _irq: LnIRQ,
    pub _stateTx: bool,
    pub _adr: u32,
    pub _mutex: xMutex,
    pub _txDone: xBinarySemaphore,
    pub _cur: *mut u8,
    pub _tail: *mut u8,
    pub _txState: lnSerial_txState,
    pub _txDma: lnDMA,
}
pub const lnSerial_txState_txIdle: lnSerial_txState = 0;
pub const lnSerial_txState_txTransmitting: lnSerial_txState = 1;
pub const lnSerial_txState_txLast: lnSerial_txState = 2;
pub type lnSerial_txState = ::std::os::raw::c_uint;
pub const lnSerial_txMode_txNone: lnSerial_txMode = 0;
pub const lnSerial_txMode_txInterrupt: lnSerial_txMode = 1;
pub const lnSerial_txMode_txDma: lnSerial_txMode = 2;
pub type lnSerial_txMode = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial4initEv"]
    pub fn lnSerial_init(this: *mut lnSerial) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial8setSpeedEi"]
    pub fn lnSerial_setSpeed(this: *mut lnSerial, speed: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial8enableTxENS_6txModeE"]
    pub fn lnSerial_enableTx(this: *mut lnSerial, mode: lnSerial_txMode) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial8transmitEiPh"]
    pub fn lnSerial_transmit(
        this: *mut lnSerial,
        size: ::std::os::raw::c_int,
        buffer: *mut u8,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial11dmaTransmitEiPh"]
    pub fn lnSerial_dmaTransmit(
        this: *mut lnSerial,
        size: ::std::os::raw::c_int,
        buffer: *mut u8,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial10_interruptEv"]
    pub fn lnSerial__interrupt(this: *mut lnSerial);
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial10interruptsEi"]
    pub fn lnSerial_interrupts(instance: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial7txDmaCbEv"]
    pub fn lnSerial_txDmaCb(this: *mut lnSerial);
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial12_dmaCallbackEPvN5lnDMA16DmaInterruptTypeE"]
    pub fn lnSerial__dmaCallback(c: *mut ::std::os::raw::c_void, it: lnDMA_DmaInterruptType);
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerialC1Ei"]
    pub fn lnSerial_lnSerial(this: *mut lnSerial, instance: ::std::os::raw::c_int);
}
impl lnSerial {
    #[inline]
    pub unsafe fn init(&mut self) -> bool {
        lnSerial_init(self)
    }
    #[inline]
    pub unsafe fn setSpeed(&mut self, speed: ::std::os::raw::c_int) -> bool {
        lnSerial_setSpeed(self, speed)
    }
    #[inline]
    pub unsafe fn enableTx(&mut self, mode: lnSerial_txMode) -> bool {
        lnSerial_enableTx(self, mode)
    }
    #[inline]
    pub unsafe fn transmit(&mut self, size: ::std::os::raw::c_int, buffer: *mut u8) -> bool {
        lnSerial_transmit(self, size, buffer)
    }
    #[inline]
    pub unsafe fn dmaTransmit(&mut self, size: ::std::os::raw::c_int, buffer: *mut u8) -> bool {
        lnSerial_dmaTransmit(self, size, buffer)
    }
    #[inline]
    pub unsafe fn _interrupt(&mut self) {
        lnSerial__interrupt(self)
    }
    #[inline]
    pub unsafe fn interrupts(instance: ::std::os::raw::c_int) {
        lnSerial_interrupts(instance)
    }
    #[inline]
    pub unsafe fn txDmaCb(&mut self) {
        lnSerial_txDmaCb(self)
    }
    #[inline]
    pub unsafe fn _dmaCallback(c: *mut ::std::os::raw::c_void, it: lnDMA_DmaInterruptType) {
        lnSerial__dmaCallback(c, it)
    }
    #[inline]
    pub unsafe fn new(instance: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        lnSerial_lnSerial(__bindgen_tmp.as_mut_ptr(), instance);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lnStopWatch {
    pub _start: u32,
    pub _end: u32,
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnStopWatch7restartEi"]
    pub fn lnStopWatch_restart(this: *mut lnStopWatch, durationMs: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnStopWatch7elapsedEv"]
    pub fn lnStopWatch_elapsed(this: *mut lnStopWatch) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnStopWatchC1Ei"]
    pub fn lnStopWatch_lnStopWatch(this: *mut lnStopWatch, ms: ::std::os::raw::c_int);
}
impl lnStopWatch {
    #[inline]
    pub unsafe fn restart(&mut self, durationMs: ::std::os::raw::c_int) -> bool {
        lnStopWatch_restart(self, durationMs)
    }
    #[inline]
    pub unsafe fn elapsed(&mut self) -> bool {
        lnStopWatch_elapsed(self)
    }
    #[inline]
    pub unsafe fn new(ms: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        lnStopWatch_lnStopWatch(__bindgen_tmp.as_mut_ptr(), ms);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lnCycleClock {
    pub _start: u32,
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnCycleClock7restartEv"]
    pub fn lnCycleClock_restart(this: *mut lnCycleClock);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnCycleClock7elapsedEv"]
    pub fn lnCycleClock_elapsed(this: *mut lnCycleClock) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnCycleClockC1Ev"]
    pub fn lnCycleClock_lnCycleClock(this: *mut lnCycleClock);
}
impl lnCycleClock {
    #[inline]
    pub unsafe fn restart(&mut self) {
        lnCycleClock_restart(self)
    }
    #[inline]
    pub unsafe fn elapsed(&mut self) -> u32 {
        lnCycleClock_elapsed(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        lnCycleClock_lnCycleClock(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
pub type lnTimerIrq =
    ::std::option::Option<unsafe extern "C" fn(cookie: *mut ::std::os::raw::c_void)>;
pub const lnTimerMode_lnTimerModePwm0: lnTimerMode = 0;
pub const lnTimerMode_lnTimerModePwm1: lnTimerMode = 1;
pub type lnTimerMode = ::std::os::raw::c_uint;
#[repr(C)]
pub struct lnTimer__bindgen_vtable(::std::os::raw::c_void);
#[doc = " \\brief Careful all the channels of a given timer share the same frequency!"]
#[doc = " Max frequency is around 100 kHz in PWM mode !"]
#[doc = ""]
#[doc = ""]
#[doc = " In all mode , after setup the channel is disabled"]
#[doc = " You have to explicitely call timer->enable()"]
#[doc = ""]
#[doc = " @param timer"]
#[doc = " @param channel"]
#[repr(C)]
#[derive(Debug)]
pub struct lnTimer {
    pub vtable_: *const lnTimer__bindgen_vtable,
    pub _timer: ::std::os::raw::c_int,
    pub _channel: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer10setPwmModeEi"]
    pub fn lnTimer_setPwmMode(this: *mut lnTimer, ratio1024: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer15setPwmFrequencyEi"]
    pub fn lnTimer_setPwmFrequency(this: *mut lnTimer, fqInHz: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer15setChannelRatioEi"]
    pub fn lnTimer_setChannelRatio(this: *mut lnTimer, ratio1024: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer10singleShotEib"]
    pub fn lnTimer_singleShot(this: *mut lnTimer, durationMs: ::std::os::raw::c_int, down: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer13setForceStateEb"]
    pub fn lnTimer_setForceState(this: *mut lnTimer, forceHigh: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer7disableEv"]
    pub fn lnTimer_disable(this: *mut lnTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer6enableEv"]
    pub fn lnTimer_enable(this: *mut lnTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer16setTickFrequencyEi"]
    pub fn lnTimer_setTickFrequency(this: *mut lnTimer, fqInHz: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer7setModeE11lnTimerMode"]
    pub fn lnTimer_setMode(this: *mut lnTimer, mode: lnTimerMode);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimerC1Eii"]
    pub fn lnTimer_lnTimer(
        this: *mut lnTimer,
        timer: ::std::os::raw::c_int,
        channel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimerC1Ei"]
    pub fn lnTimer_lnTimer1(this: *mut lnTimer, pin: ::std::os::raw::c_int);
}
impl lnTimer {
    #[inline]
    pub unsafe fn setPwmMode(&mut self, ratio1024: ::std::os::raw::c_int) {
        lnTimer_setPwmMode(self, ratio1024)
    }
    #[inline]
    pub unsafe fn setPwmFrequency(&mut self, fqInHz: ::std::os::raw::c_int) {
        lnTimer_setPwmFrequency(self, fqInHz)
    }
    #[inline]
    pub unsafe fn setChannelRatio(&mut self, ratio1024: ::std::os::raw::c_int) {
        lnTimer_setChannelRatio(self, ratio1024)
    }
    #[inline]
    pub unsafe fn singleShot(&mut self, durationMs: ::std::os::raw::c_int, down: bool) {
        lnTimer_singleShot(self, durationMs, down)
    }
    #[inline]
    pub unsafe fn setForceState(&mut self, forceHigh: bool) {
        lnTimer_setForceState(self, forceHigh)
    }
    #[inline]
    pub unsafe fn disable(&mut self) {
        lnTimer_disable(self)
    }
    #[inline]
    pub unsafe fn enable(&mut self) {
        lnTimer_enable(self)
    }
    #[inline]
    pub unsafe fn setTickFrequency(&mut self, fqInHz: ::std::os::raw::c_int) {
        lnTimer_setTickFrequency(self, fqInHz)
    }
    #[inline]
    pub unsafe fn setMode(&mut self, mode: lnTimerMode) {
        lnTimer_setMode(self, mode)
    }
    #[inline]
    pub unsafe fn new(timer: ::std::os::raw::c_int, channel: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        lnTimer_lnTimer(__bindgen_tmp.as_mut_ptr(), timer, channel);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(pin: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        lnTimer_lnTimer1(__bindgen_tmp.as_mut_ptr(), pin);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimerD1Ev"]
    pub fn lnTimer_lnTimer_destructor(this: *mut lnTimer);
}
#[doc = " @param instance"]
#[repr(C)]
#[derive(Debug)]
pub struct lnAdcTimer {
    pub _base: lnTimer,
    pub _actualPwmFrequency: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnAdcTimer15setPwmFrequencyEi"]
    pub fn lnAdcTimer_setPwmFrequency(this: *mut lnAdcTimer, fqInHz: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnAdcTimer15getPwmFrequencyEv"]
    pub fn lnAdcTimer_getPwmFrequency(this: *mut lnAdcTimer) -> ::std::os::raw::c_int;
}
impl lnAdcTimer {
    #[inline]
    pub unsafe fn setPwmFrequency(&mut self, fqInHz: ::std::os::raw::c_int) {
        lnAdcTimer_setPwmFrequency(self, fqInHz)
    }
    #[inline]
    pub unsafe fn getPwmFrequency(&mut self) -> ::std::os::raw::c_int {
        lnAdcTimer_getPwmFrequency(self)
    }
}
#[repr(C)]
pub struct lnDmaTimerCallback__bindgen_vtable(::std::os::raw::c_void);
#[doc = " /!\\ Changing the frequency alters ALL channels"]
#[doc = " @param timer"]
#[doc = " @param channel"]
#[doc = " @return"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lnDmaTimerCallback {
    pub vtable_: *const lnDmaTimerCallback__bindgen_vtable,
}
#[doc = " @param pin"]
#[repr(C)]
#[derive(Debug)]
pub struct lnDmaTimer {
    pub _base: lnTimer,
    pub _cb: *mut lnDmaTimerCallback,
    pub _rollover: ::std::os::raw::c_int,
    pub _dma: *mut lnDMA,
    pub _bits: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimer8pwmSetupEi"]
    pub fn lnDmaTimer_pwmSetup(this: *mut lnDmaTimer, frequency: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimer8rolloverEv"]
    pub fn lnDmaTimer_rollover(this: *mut lnDmaTimer) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimer17attachDmaCallbackEP18lnDmaTimerCallback"]
    pub fn lnDmaTimer_attachDmaCallback(this: *mut lnDmaTimer, cb: *mut lnDmaTimerCallback)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimer5startEiPh"]
    pub fn lnDmaTimer_start(
        this: *mut lnDmaTimer,
        nbSample: ::std::os::raw::c_int,
        data: *mut u8,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimer4stopEv"]
    pub fn lnDmaTimer_stop(this: *mut lnDmaTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimer16setTickFrequencyEi"]
    pub fn lnDmaTimer_setTickFrequency(this: *mut lnDmaTimer, fq: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimer12dmaInterruptEb"]
    pub fn lnDmaTimer_dmaInterrupt(this: *mut lnDmaTimer, h: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimerC1Eii"]
    pub fn lnDmaTimer_lnDmaTimer(this: *mut lnDmaTimer, bits: ::std::os::raw::c_int, pin: lnPin);
}
impl lnDmaTimer {
    #[inline]
    pub unsafe fn pwmSetup(&mut self, frequency: ::std::os::raw::c_int) -> bool {
        lnDmaTimer_pwmSetup(self, frequency)
    }
    #[inline]
    pub unsafe fn rollover(&mut self) -> ::std::os::raw::c_int {
        lnDmaTimer_rollover(self)
    }
    #[inline]
    pub unsafe fn attachDmaCallback(&mut self, cb: *mut lnDmaTimerCallback) -> bool {
        lnDmaTimer_attachDmaCallback(self, cb)
    }
    #[inline]
    pub unsafe fn start(&mut self, nbSample: ::std::os::raw::c_int, data: *mut u8) -> bool {
        lnDmaTimer_start(self, nbSample, data)
    }
    #[inline]
    pub unsafe fn stop(&mut self) {
        lnDmaTimer_stop(self)
    }
    #[inline]
    pub unsafe fn setTickFrequency(&mut self, fq: ::std::os::raw::c_int) -> bool {
        lnDmaTimer_setTickFrequency(self, fq)
    }
    #[inline]
    pub unsafe fn dmaInterrupt(&mut self, h: bool) {
        lnDmaTimer_dmaInterrupt(self, h)
    }
    #[inline]
    pub unsafe fn new(bits: ::std::os::raw::c_int, pin: lnPin) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        lnDmaTimer_lnDmaTimer(__bindgen_tmp.as_mut_ptr(), bits, pin);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimerD1Ev"]
    pub fn lnDmaTimer_lnDmaTimer_destructor(this: *mut lnDmaTimer);
}
#[doc = " \\brief careful : this will use the whole timer,  not just a channel"]
#[repr(C)]
#[derive(Debug)]
pub struct lnDelayTimer {
    pub _base: lnTimer,
    pub _handler: lnTimerIrq,
    pub _cookie: *mut ::std::os::raw::c_void,
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnDelayTimer3armEi"]
    pub fn lnDelayTimer_arm(this: *mut lnDelayTimer, delayUs: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnDelayTimer12setInterruptEPFvPvES0_"]
    pub fn lnDelayTimer_setInterrupt(
        this: *mut lnDelayTimer,
        handler: lnTimerIrq,
        cookie: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnDelayTimer16interruptHandlerEi"]
    pub fn lnDelayTimer_interruptHandler(timer: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnDelayTimer3irqEv"]
    pub fn lnDelayTimer_irq(this: *mut lnDelayTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnDelayTimer15enableInterruptEv"]
    pub fn lnDelayTimer_enableInterrupt(this: *mut lnDelayTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnDelayTimer16disableInterruptEv"]
    pub fn lnDelayTimer_disableInterrupt(this: *mut lnDelayTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnDelayTimerC1Eii"]
    pub fn lnDelayTimer_lnDelayTimer(
        this: *mut lnDelayTimer,
        timer: ::std::os::raw::c_int,
        channel: ::std::os::raw::c_int,
    );
}
impl lnDelayTimer {
    #[inline]
    pub unsafe fn arm(&mut self, delayUs: ::std::os::raw::c_int) {
        lnDelayTimer_arm(self, delayUs)
    }
    #[inline]
    pub unsafe fn setInterrupt(
        &mut self,
        handler: lnTimerIrq,
        cookie: *mut ::std::os::raw::c_void,
    ) {
        lnDelayTimer_setInterrupt(self, handler, cookie)
    }
    #[inline]
    pub unsafe fn interruptHandler(timer: ::std::os::raw::c_int) {
        lnDelayTimer_interruptHandler(timer)
    }
    #[inline]
    pub unsafe fn irq(&mut self) {
        lnDelayTimer_irq(self)
    }
    #[inline]
    pub unsafe fn enableInterrupt(&mut self) {
        lnDelayTimer_enableInterrupt(self)
    }
    #[inline]
    pub unsafe fn disableInterrupt(&mut self) {
        lnDelayTimer_disableInterrupt(self)
    }
    #[inline]
    pub unsafe fn new(timer: ::std::os::raw::c_int, channel: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        lnDelayTimer_lnDelayTimer(__bindgen_tmp.as_mut_ptr(), timer, channel);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnDelayTimerD1Ev"]
    pub fn lnDelayTimer_lnDelayTimer_destructor(this: *mut lnDelayTimer);
}
