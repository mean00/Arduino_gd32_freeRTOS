#![no_std]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    unsafe{
    deadEnd(-10);
    }
    loop {}
}
/* automatically generated by rust-bindgen 0.59.2 */

pub const _STDIO_H_: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"4.1.0\0";
pub const _PICOLIBC_MINOR__: u32 = 7;
pub const _PICOLIBC_VERSION: &[u8; 6usize] = b"1.7.4\0";
pub const _PICOLIBC__: u32 = 1;
pub const __NEWLIB_MINOR__: u32 = 1;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const __NEWLIB__: u32 = 4;
pub const __PICOLIBC_MINOR__: u32 = 7;
pub const __PICOLIBC_PATCHLEVEL__: u32 = 4;
pub const __PICOLIBC_VERSION__: &[u8; 6usize] = b"1.7.4\0";
pub const __PICOLIBC__: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT_FLOAT: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT_DOUBLE: u32 = 0;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __OBSOLETE_MATH_FLOAT: u32 = 1;
pub const __OBSOLETE_MATH_DOUBLE: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __RAND_MAX: u32 = 2147483647;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __PICOLIBC_UNGETC_SIZE: u32 = 2;
pub const __SRD: u32 = 1;
pub const __SWR: u32 = 2;
pub const __SERR: u32 = 4;
pub const __SEOF: u32 = 8;
pub const __SCLOSE: u32 = 16;
pub const EOF: i32 = -1;
pub const _FDEV_SETUP_READ: u32 = 1;
pub const _FDEV_SETUP_WRITE: u32 = 2;
pub const _FDEV_SETUP_RW: u32 = 3;
pub const _FDEV_ERR: i32 = -1;
pub const _FDEV_EOF: i32 = -2;
pub const BUFSIZ: u32 = 512;
pub const _IONBF: u32 = 0;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const LN_ARCH_UNKNOWN: u32 = 0;
pub const LN_ARCH_RISCV: u32 = 1;
pub const LN_ARCH_ARM: u32 = 2;
pub const INPUT: u32 = 0;
pub const OUTPUT: u32 = 1;
pub const INPUT_PULLUP: u32 = 2;
pub const NONE: u32 = 0;
pub const CHANGE: u32 = 1;
pub const FALLING: u32 = 2;
pub const RISING: u32 = 3;
pub const LOW: u32 = 0;
pub const HIGH: u32 = 1;
pub const configPRIO_BITS: u32 = 4;
pub const configLIBRARY_LOWEST_INTERRUPT_PRIORITY: u32 = 15;
pub const configKERNEL_INTERRUPT_PRIORITY: u32 = 240;
pub const configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY: u32 = 5;
pub const configMAX_SYSCALL_INTERRUPT_PRIORITY: u32 = 80;
pub const configUSE_MALLOC_FAILED_HOOK: u32 = 1;
pub const configSUPPORT_DYNAMIC_ALLOCATION: u32 = 1;
pub const configSUPPORT_STATIC_ALLOCATION: u32 = 0;
pub const configUSE_DAEMON_TASK_STARTUP_HOOK: u32 = 0;
pub const configUSE_PREEMPTION: u32 = 1;
pub const configUSE_IDLE_HOOK: u32 = 0;
pub const configUSE_TICK_HOOK: u32 = 1;
pub const configMAX_PRIORITIES: u32 = 16;
pub const configAPPLICATION_ALLOCATED_HEAP: u32 = 1;
pub const configMAX_TASK_NAME_LEN: u32 = 16;
pub const configUSE_TRACE_FACILITY: u32 = 1;
pub const configUSE_16_BIT_TICKS: u32 = 0;
pub const configIDLE_SHOULD_YIELD: u32 = 1;
pub const configUSE_TASK_NOTIFICATIONS: u32 = 1;
pub const configTASK_NOTIFICATION_ARRAY_ENTRIES: u32 = 5;
pub const configTIMER_TASK_PRIORITY: u32 = 5;
pub const configUSE_TIMERS: u32 = 0;
pub const configTIMER_TASK_STACK_DEPTH: u32 = 400;
pub const configTIMER_QUEUE_LENGTH: u32 = 10;
pub const INCLUDE_xTimerPendFunctionCall: u32 = 0;
pub const configUSE_CO_ROUTINES: u32 = 0;
pub const configMAX_CO_ROUTINE_PRIORITIES: u32 = 2;
pub const INCLUDE_vTaskPrioritySet: u32 = 0;
pub const INCLUDE_uxTaskPriorityGet: u32 = 0;
pub const INCLUDE_vTaskDelete: u32 = 1;
pub const INCLUDE_vTaskCleanUpResources: u32 = 0;
pub const INCLUDE_vTaskSuspend: u32 = 1;
pub const INCLUDE_vTaskDelayUntil: u32 = 1;
pub const INCLUDE_vTaskDelay: u32 = 1;
pub const configUSE_MUTEXES: u32 = 1;
pub const configUSE_COUNTING_SEMAPHORES: u32 = 1;
pub const configUSE_ALTERNATIVE_API: u32 = 0;
pub const configUSE_TIME_SLICING: u32 = 0;
pub const configCHECK_FOR_STACK_OVERFLOW: u32 = 2;
pub const configUSE_RECURSIVE_MUTEXES: u32 = 1;
pub const configQUEUE_REGISTRY_SIZE: u32 = 0;
pub const configGENERATE_RUN_TIME_STATS: u32 = 0;
pub const errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY: i32 = -1;
pub const errQUEUE_BLOCKED: i32 = -4;
pub const errQUEUE_YIELD: i32 = -5;
pub const configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES: u32 = 0;
pub const pdINTEGRITY_CHECK_VALUE: u32 = 1515870810;
pub const pdFREERTOS_ERRNO_NONE: u32 = 0;
pub const pdFREERTOS_ERRNO_ENOENT: u32 = 2;
pub const pdFREERTOS_ERRNO_EINTR: u32 = 4;
pub const pdFREERTOS_ERRNO_EIO: u32 = 5;
pub const pdFREERTOS_ERRNO_ENXIO: u32 = 6;
pub const pdFREERTOS_ERRNO_EBADF: u32 = 9;
pub const pdFREERTOS_ERRNO_EAGAIN: u32 = 11;
pub const pdFREERTOS_ERRNO_EWOULDBLOCK: u32 = 11;
pub const pdFREERTOS_ERRNO_ENOMEM: u32 = 12;
pub const pdFREERTOS_ERRNO_EACCES: u32 = 13;
pub const pdFREERTOS_ERRNO_EFAULT: u32 = 14;
pub const pdFREERTOS_ERRNO_EBUSY: u32 = 16;
pub const pdFREERTOS_ERRNO_EEXIST: u32 = 17;
pub const pdFREERTOS_ERRNO_EXDEV: u32 = 18;
pub const pdFREERTOS_ERRNO_ENODEV: u32 = 19;
pub const pdFREERTOS_ERRNO_ENOTDIR: u32 = 20;
pub const pdFREERTOS_ERRNO_EISDIR: u32 = 21;
pub const pdFREERTOS_ERRNO_EINVAL: u32 = 22;
pub const pdFREERTOS_ERRNO_ENOSPC: u32 = 28;
pub const pdFREERTOS_ERRNO_ESPIPE: u32 = 29;
pub const pdFREERTOS_ERRNO_EROFS: u32 = 30;
pub const pdFREERTOS_ERRNO_EUNATCH: u32 = 42;
pub const pdFREERTOS_ERRNO_EBADE: u32 = 50;
pub const pdFREERTOS_ERRNO_EFTYPE: u32 = 79;
pub const pdFREERTOS_ERRNO_ENMFILE: u32 = 89;
pub const pdFREERTOS_ERRNO_ENOTEMPTY: u32 = 90;
pub const pdFREERTOS_ERRNO_ENAMETOOLONG: u32 = 91;
pub const pdFREERTOS_ERRNO_EOPNOTSUPP: u32 = 95;
pub const pdFREERTOS_ERRNO_ENOBUFS: u32 = 105;
pub const pdFREERTOS_ERRNO_ENOPROTOOPT: u32 = 109;
pub const pdFREERTOS_ERRNO_EADDRINUSE: u32 = 112;
pub const pdFREERTOS_ERRNO_ETIMEDOUT: u32 = 116;
pub const pdFREERTOS_ERRNO_EINPROGRESS: u32 = 119;
pub const pdFREERTOS_ERRNO_EALREADY: u32 = 120;
pub const pdFREERTOS_ERRNO_EADDRNOTAVAIL: u32 = 125;
pub const pdFREERTOS_ERRNO_EISCONN: u32 = 127;
pub const pdFREERTOS_ERRNO_ENOTCONN: u32 = 128;
pub const pdFREERTOS_ERRNO_ENOMEDIUM: u32 = 135;
pub const pdFREERTOS_ERRNO_EILSEQ: u32 = 138;
pub const pdFREERTOS_ERRNO_ECANCELED: u32 = 140;
pub const pdFREERTOS_LITTLE_ENDIAN: u32 = 0;
pub const pdFREERTOS_BIG_ENDIAN: u32 = 1;
pub const pdLITTLE_ENDIAN: u32 = 0;
pub const pdBIG_ENDIAN: u32 = 1;
pub const portTICK_TYPE_IS_ATOMIC: u32 = 1;
pub const portSTACK_GROWTH: i32 = -1;
pub const portBYTE_ALIGNMENT: u32 = 8;
pub const portNVIC_PENDSVSET_BIT: u32 = 268435456;
pub const configUSE_PORT_OPTIMISED_TASK_SELECTION: u32 = 1;
pub const portBYTE_ALIGNMENT_MASK: u32 = 7;
pub const portUSING_MPU_WRAPPERS: u32 = 0;
pub const portNUM_CONFIGURABLE_REGIONS: u32 = 1;
pub const portHAS_STACK_OVERFLOW_CHECKING: u32 = 0;
pub const configSTACK_ALLOCATION_FROM_SEPARATE_HEAP: u32 = 0;
pub const configUSE_NEWLIB_REENTRANT: u32 = 0;
pub const INCLUDE_xTaskDelayUntil: u32 = 1;
pub const INCLUDE_xTaskGetIdleTaskHandle: u32 = 0;
pub const INCLUDE_xTaskAbortDelay: u32 = 0;
pub const INCLUDE_xQueueGetMutexHolder: u32 = 0;
pub const INCLUDE_xSemaphoreGetMutexHolder: u32 = 0;
pub const INCLUDE_xTaskGetHandle: u32 = 0;
pub const INCLUDE_uxTaskGetStackHighWaterMark: u32 = 0;
pub const INCLUDE_uxTaskGetStackHighWaterMark2: u32 = 0;
pub const INCLUDE_eTaskGetState: u32 = 0;
pub const INCLUDE_xTaskResumeFromISR: u32 = 1;
pub const INCLUDE_xTaskGetSchedulerState: u32 = 0;
pub const INCLUDE_xTaskGetCurrentTaskHandle: u32 = 0;
pub const configUSE_APPLICATION_TASK_TAG: u32 = 0;
pub const configNUM_THREAD_LOCAL_STORAGE_POINTERS: u32 = 0;
pub const portCRITICAL_NESTING_IN_TCB: u32 = 0;
pub const configASSERT_DEFINED: u32 = 1;
pub const configPRECONDITION_DEFINED: u32 = 0;
pub const configRECORD_STACK_HIGH_ADDRESS: u32 = 0;
pub const configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H: u32 = 0;
pub const configEXPECTED_IDLE_TIME_BEFORE_SLEEP: u32 = 2;
pub const configUSE_TICKLESS_IDLE: u32 = 0;
pub const configUSE_QUEUE_SETS: u32 = 0;
pub const configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS: u32 = 0;
pub const configUSE_STATS_FORMATTING_FUNCTIONS: u32 = 0;
pub const configUSE_POSIX_ERRNO: u32 = 0;
pub const configINITIAL_TICK_COUNT: u32 = 0;
pub const configENABLE_BACKWARD_COMPATIBILITY: u32 = 1;
pub const configUSE_TASK_FPU_SUPPORT: u32 = 1;
pub const configENABLE_MPU: u32 = 0;
pub const configENABLE_FPU: u32 = 1;
pub const configENABLE_TRUSTZONE: u32 = 1;
pub const configRUN_FREERTOS_SECURE_ONLY: u32 = 0;
pub const configRUN_ADDITIONAL_TESTS: u32 = 0;
pub const tskKERNEL_VERSION_NUMBER: &[u8; 8usize] = b"V10.4.3\0";
pub const tskKERNEL_VERSION_MAJOR: u32 = 10;
pub const tskKERNEL_VERSION_MINOR: u32 = 4;
pub const tskKERNEL_VERSION_BUILD: u32 = 3;
pub const tskMPU_REGION_READ_ONLY: u32 = 1;
pub const tskMPU_REGION_READ_WRITE: u32 = 2;
pub const tskMPU_REGION_EXECUTE_NEVER: u32 = 4;
pub const tskMPU_REGION_NORMAL_MEMORY: u32 = 8;
pub const tskMPU_REGION_DEVICE_MEMORY: u32 = 16;
pub const tskDEFAULT_INDEX_TO_NOTIFY: u32 = 0;
pub const LN_IRQ_OFFSET: u32 = 0;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_longlong;
pub type __uint64_t = cty::c_ulonglong;
pub type __int_least8_t = cty::c_schar;
pub type __uint_least8_t = cty::c_uchar;
pub type __int_least16_t = cty::c_short;
pub type __uint_least16_t = cty::c_ushort;
pub type __int_least32_t = cty::c_int;
pub type __uint_least32_t = cty::c_uint;
pub type __int_least64_t = cty::c_longlong;
pub type __uint_least64_t = cty::c_ulonglong;
pub type __intmax_t = cty::c_longlong;
pub type __uintmax_t = cty::c_ulonglong;
pub type __intptr_t = cty::c_int;
pub type __uintptr_t = cty::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type uint_fast8_t = cty::c_uchar;
pub type int_fast16_t = cty::c_short;
pub type uint_fast16_t = cty::c_ushort;
pub type int_fast32_t = cty::c_int;
pub type uint_fast32_t = cty::c_uint;
pub type int_fast64_t = cty::c_longlong;
pub type uint_fast64_t = cty::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
pub type locale_t = *mut __locale_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
extern "C" {
    pub fn imaxabs(arg1: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denomer: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        arg1: *const cty::c_char,
        arg2: *mut *mut cty::c_char,
        arg3: cty::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        arg1: *const cty::c_char,
        arg2: *mut *mut cty::c_char,
        arg3: cty::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(arg1: *const u32, arg2: *mut *mut u32, arg3: cty::c_int) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(arg1: *const u32, arg2: *mut *mut u32, arg3: cty::c_int) -> uintmax_t;
}
extern "C" {
    pub fn strtoimax_l(
        arg1: *const cty::c_char,
        _restrict: *mut *mut cty::c_char,
        arg2: cty::c_int,
        arg3: locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax_l(
        arg1: *const cty::c_char,
        _restrict: *mut *mut cty::c_char,
        arg2: cty::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax_l(
        arg1: *const u32,
        _restrict: *mut *mut u32,
        arg2: cty::c_int,
        arg3: locale_t,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax_l(
        arg1: *const u32,
        _restrict: *mut *mut u32,
        arg2: cty::c_int,
        arg3: locale_t,
    ) -> uintmax_t;
}
pub type va_list = u32;
pub type __gnuc_va_list = u32;
pub type size_t = cty::c_uint;
pub type wint_t = cty::c_int;
pub type __blkcnt_t = cty::c_long;
pub type __blksize_t = cty::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = cty::c_long;
pub type __pid_t = cty::c_int;
pub type __dev_t = cty::c_short;
pub type __uid_t = cty::c_ushort;
pub type __gid_t = cty::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = cty::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = cty::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = cty::c_long;
pub type _fpos_t = cty::c_long;
pub type __size_t = cty::c_uint;
pub type _ssize_t = cty::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: cty::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [cty::c_uchar; 4usize],
}
pub type _iconv_t = *mut cty::c_void;
pub type __clock_t = cty::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = cty::c_ulong;
pub type __timer_t = cty::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = cty::c_int;
pub type __nlink_t = cty::c_ushort;
pub type __suseconds_t = cty::c_long;
pub type __useconds_t = cty::c_ulong;
pub type __ungetc_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __file {
    pub unget: __ungetc_t,
    pub flags: u8,
    pub put: ::core::option::Option<
        unsafe extern "C" fn(arg1: cty::c_char, arg2: *mut __file) -> cty::c_int,
    >,
    pub get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut __file) -> cty::c_int>,
    pub flush: ::core::option::Option<unsafe extern "C" fn(arg1: *mut __file) -> cty::c_int>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __file_close {
    pub file: __file,
    pub close: ::core::option::Option<unsafe extern "C" fn(arg1: *mut __file) -> cty::c_int>,
}
pub type __FILE = __file;
pub type FILE = __FILE;
extern "C" {
    pub static stdin: *mut FILE;
}
extern "C" {
    pub static stdout: *mut FILE;
}
extern "C" {
    pub static stderr: *mut FILE;
}
extern "C" {
    pub fn fdevopen(
        __put: ::core::option::Option<
            unsafe extern "C" fn(arg1: cty::c_char, arg2: *mut FILE) -> cty::c_int,
        >,
        __get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut FILE) -> cty::c_int>,
        __flush: ::core::option::Option<unsafe extern "C" fn(arg1: *mut FILE) -> cty::c_int>,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn vfprintf(__stream: *mut FILE, __fmt: *const cty::c_char, __ap: va_list) -> cty::c_int;
}
extern "C" {
    pub fn fputc(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putc(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putchar(__c: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn printf(__fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vprintf(__fmt: *const cty::c_char, __ap: va_list) -> cty::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut cty::c_char, __fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut cty::c_char,
        __n: size_t,
        __fmt: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsprintf(__s: *mut cty::c_char, __fmt: *const cty::c_char, ap: va_list) -> cty::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut cty::c_char,
        __n: size_t,
        __fmt: *const cty::c_char,
        ap: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn asprintf(strp: *mut *mut cty::c_char, fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vasprintf(
        strp: *mut *mut cty::c_char,
        fmt: *const cty::c_char,
        ap: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fputs(__str: *const cty::c_char, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn puts(__str: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const cty::c_void,
        __size: size_t,
        __nmemb: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getchar() -> cty::c_int;
}
extern "C" {
    pub fn ungetc(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fgets(
        __str: *mut cty::c_char,
        __size: cty::c_int,
        __stream: *mut FILE,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn gets(__str: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn fread(
        __ptr: *mut cty::c_void,
        __size: size_t,
        __nmemb: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn vfscanf(__stream: *mut FILE, __fmt: *const cty::c_char, __ap: va_list) -> cty::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn scanf(__fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vscanf(__fmt: *const cty::c_char, __ap: va_list) -> cty::c_int;
}
extern "C" {
    pub fn sscanf(__buf: *const cty::c_char, __fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vsscanf(__buf: *const cty::c_char, __fmt: *const cty::c_char, ap: va_list)
        -> cty::c_int;
}
extern "C" {
    pub fn fflush(stream: *mut FILE) -> cty::c_int;
}
pub type fpos_t = cty::c_longlong;
extern "C" {
    pub fn fgetpos(stream: *mut FILE, pos: *mut fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn fopen(path: *const cty::c_char, mode: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        path: *const cty::c_char,
        mode: *const cty::c_char,
        stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(arg1: cty::c_int, arg2: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fseek(stream: *mut FILE, offset: cty::c_long, whence: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn fsetpos(stream: *mut FILE, pos: *mut fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn ftell(stream: *mut FILE) -> cty::c_long;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn perror(s: *const cty::c_char);
}
extern "C" {
    pub fn remove(pathname: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn rename(oldpath: *const cty::c_char, newpath: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn rewind(stream: *mut FILE);
}
extern "C" {
    pub fn setbuf(stream: *mut FILE, buf: *mut cty::c_char);
}
extern "C" {
    pub fn setvbuf(
        stream: *mut FILE,
        buf: *mut cty::c_char,
        mode: cty::c_int,
        size: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(s: *mut cty::c_char) -> *mut cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
extern "C" {
    pub fn bcmp(arg1: *const cty::c_void, arg2: *const cty::c_void, arg3: size_t) -> cty::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const cty::c_void, arg2: *mut cty::c_void, arg3: size_t);
}
extern "C" {
    pub fn bzero(arg1: *mut cty::c_void, arg2: size_t);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut cty::c_void, arg2: size_t);
}
extern "C" {
    pub fn ffs(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ffsl(arg1: cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn ffsll(arg1: cty::c_longlong) -> cty::c_int;
}
extern "C" {
    pub fn fls(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn flsl(arg1: cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn flsll(arg1: cty::c_longlong) -> cty::c_int;
}
extern "C" {
    pub fn index(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn rindex(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcasecmp(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: size_t,
        arg4: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memchr(arg1: *const cty::c_void, arg2: cty::c_int, arg3: size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn memcmp(arg1: *const cty::c_void, arg2: *const cty::c_void, arg3: size_t) -> cty::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut cty::c_void,
        arg2: *const cty::c_void,
        arg3: size_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut cty::c_void,
        arg2: *const cty::c_void,
        arg3: size_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memset(arg1: *mut cty::c_void, arg2: cty::c_int, arg3: size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn strcat(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strchr(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcmp(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strcoll(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strcpy(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcspn(arg1: *const cty::c_char, arg2: *const cty::c_char) -> size_t;
}
extern "C" {
    pub fn strerror(arg1: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const cty::c_char) -> size_t;
}
extern "C" {
    pub fn strncat(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: size_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strncmp(arg1: *const cty::c_char, arg2: *const cty::c_char, arg3: size_t) -> cty::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: size_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strpbrk(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strrchr(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const cty::c_char, arg2: *const cty::c_char) -> size_t;
}
extern "C" {
    pub fn strstr(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strtok(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strxfrm(arg1: *mut cty::c_char, arg2: *const cty::c_char, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn strcoll_l(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strerror_l(arg1: cty::c_int, arg2: locale_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn strxfrm_l(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: size_t,
        arg4: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const cty::c_void,
        arg2: *const cty::c_void,
        arg3: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn timingsafe_memcmp(
        arg1: *const cty::c_void,
        arg2: *const cty::c_void,
        arg3: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memccpy(
        arg1: *mut cty::c_void,
        arg2: *const cty::c_void,
        arg3: cty::c_int,
        arg4: size_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn stpcpy(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn stpncpy(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: size_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strndup(arg1: *const cty::c_char, arg2: size_t) -> *mut cty::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(arg1: cty::c_int, arg2: *mut cty::c_char, arg3: size_t) -> cty::c_int;
}
extern "C" {
    pub fn _strerror_r(
        arg1: cty::c_int,
        arg2: cty::c_int,
        arg3: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlcat(arg1: *mut cty::c_char, arg2: *const cty::c_char, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn strlcpy(arg1: *mut cty::c_char, arg2: *const cty::c_char, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn strnlen(arg1: *const cty::c_char, arg2: size_t) -> size_t;
}
extern "C" {
    pub fn strsep(arg1: *mut *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: size_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlwr(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strupr(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strsignal(__signo: cty::c_int) -> *mut cty::c_char;
}
pub const PA0: cty::c_uint = 0;
pub const PA1: cty::c_uint = 1;
pub const PA2: cty::c_uint = 2;
pub const PA3: cty::c_uint = 3;
pub const PA4: cty::c_uint = 4;
pub const PA5: cty::c_uint = 5;
pub const PA6: cty::c_uint = 6;
pub const PA7: cty::c_uint = 7;
pub const PA8: cty::c_uint = 8;
pub const PA9: cty::c_uint = 9;
pub const PA10: cty::c_uint = 10;
pub const PA11: cty::c_uint = 11;
pub const PA12: cty::c_uint = 12;
pub const PA13: cty::c_uint = 13;
pub const PA14: cty::c_uint = 14;
pub const PA15: cty::c_uint = 15;
pub const PB0: cty::c_uint = 16;
pub const PB1: cty::c_uint = 17;
pub const PB2: cty::c_uint = 18;
pub const PB3: cty::c_uint = 19;
pub const PB4: cty::c_uint = 20;
pub const PB5: cty::c_uint = 21;
pub const PB6: cty::c_uint = 22;
pub const PB7: cty::c_uint = 23;
pub const PB8: cty::c_uint = 24;
pub const PB9: cty::c_uint = 25;
pub const PB10: cty::c_uint = 26;
pub const PB11: cty::c_uint = 27;
pub const PB12: cty::c_uint = 28;
pub const PB13: cty::c_uint = 29;
pub const PB14: cty::c_uint = 30;
pub const PB15: cty::c_uint = 31;
pub const PC0: cty::c_uint = 32;
pub const PC1: cty::c_uint = 33;
pub const PC2: cty::c_uint = 34;
pub const PC3: cty::c_uint = 35;
pub const PC4: cty::c_uint = 36;
pub const PC5: cty::c_uint = 37;
pub const PC6: cty::c_uint = 38;
pub const PC7: cty::c_uint = 39;
pub const PC8: cty::c_uint = 40;
pub const PC9: cty::c_uint = 41;
pub const PC10: cty::c_uint = 42;
pub const PC11: cty::c_uint = 43;
pub const PC12: cty::c_uint = 44;
pub const PC13: cty::c_uint = 45;
pub const PC14: cty::c_uint = 46;
pub const PC15: cty::c_uint = 47;
pub const PD0: cty::c_uint = 48;
pub const PD1: cty::c_uint = 49;
pub const PD2: cty::c_uint = 50;
pub const PD3: cty::c_uint = 51;
pub const PD4: cty::c_uint = 52;
pub const PD5: cty::c_uint = 53;
pub const PD6: cty::c_uint = 54;
pub const PD7: cty::c_uint = 55;
pub const PD8: cty::c_uint = 56;
pub const PD9: cty::c_uint = 57;
pub const PD10: cty::c_uint = 58;
pub const PD11: cty::c_uint = 59;
pub const PD12: cty::c_uint = 60;
pub const PD13: cty::c_uint = 61;
pub const PD14: cty::c_uint = 62;
pub const PD15: cty::c_uint = 63;
pub const PE0: cty::c_uint = 64;
pub const PE1: cty::c_uint = 65;
pub const PE2: cty::c_uint = 66;
pub const PE3: cty::c_uint = 67;
pub const PE4: cty::c_uint = 68;
pub const PE5: cty::c_uint = 69;
pub const PE6: cty::c_uint = 70;
pub const PE7: cty::c_uint = 71;
pub const PE8: cty::c_uint = 72;
pub const PE9: cty::c_uint = 73;
pub const PE10: cty::c_uint = 74;
pub const PE11: cty::c_uint = 75;
pub const PE12: cty::c_uint = 76;
pub const PE13: cty::c_uint = 77;
pub const PE14: cty::c_uint = 78;
pub const PE15: cty::c_uint = 79;
pub type _bindgen_ty_1 = cty::c_uint;
pub const GpioMode_lnFLOATING: GpioMode = 0;
pub const GpioMode_lnINPUT_FLOATING: GpioMode = 0;
pub const GpioMode_lnINPUT_PULLUP: GpioMode = 2;
pub const GpioMode_lnINPUT_PULLDOWN: GpioMode = 3;
pub const GpioMode_lnOUTPUT: GpioMode = 1;
pub const GpioMode_lnOUTPUT_OPEN_DRAIN: GpioMode = 4;
pub const GpioMode_lnALTERNATE_PP: GpioMode = 5;
pub const GpioMode_lnALTERNATE_OD: GpioMode = 6;
pub const GpioMode_lnPWM: GpioMode = 7;
pub const GpioMode_lnADC_MODE: GpioMode = 8;
pub const GpioMode_lnDAC_MODE: GpioMode = 9;
pub type GpioMode = cty::c_uint;
pub type lnPin = cty::c_int;
extern "C" {
    #[link_name = "\u{1}_Z9lnPinModei8GpioMode"]
    pub fn lnPinMode(pin: lnPin, mode: GpioMode);
}
extern "C" {
    #[link_name = "\u{1}_Z14lnDigitalWriteib"]
    pub fn lnDigitalWrite(pin: lnPin, value: bool);
}
extern "C" {
    #[link_name = "\u{1}_Z13lnDigitalReadi"]
    pub fn lnDigitalRead(pin: lnPin) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_Z15lnDigitalTogglei"]
    pub fn lnDigitalToggle(pin: lnPin);
}
extern "C" {
    #[link_name = "\u{1}_Z23lnGetGpioToggleRegisteri"]
    pub fn lnGetGpioToggleRegister(port: cty::c_int) -> *mut cty::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_Z26lnGetGpioDirectionRegisteri"]
    pub fn lnGetGpioDirectionRegister(port: cty::c_int) -> *mut cty::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_Z22lnGetGpioValueRegisteri"]
    pub fn lnGetGpioValueRegister(port: cty::c_int) -> *mut cty::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_Z10lnReadPorti"]
    pub fn lnReadPort(port: cty::c_int) -> cty::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_Z15lnRemapTimerPini"]
    pub fn lnRemapTimerPin(timer: cty::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lnFastIO {
    pub _onoff: *mut cty::c_ulong,
    pub _onbit: cty::c_ulong,
    pub _offbit: cty::c_ulong,
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnFastIOC1Ei"]
    pub fn lnFastIO_lnFastIO(this: *mut lnFastIO, p: lnPin);
}
impl lnFastIO {
    #[inline]
    pub unsafe fn new(p: lnPin) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnFastIO_lnFastIO(__bindgen_tmp.as_mut_ptr(), p);
        __bindgen_tmp.assume_init()
    }
}
pub const lnEdge_LN_EDGE_NONE: lnEdge = 0;
pub const lnEdge_LN_EDGE_RISING: lnEdge = 1;
pub const lnEdge_LN_EDGE_FALLING: lnEdge = 2;
pub const lnEdge_LN_EDGE_BOTH: lnEdge = 3;
pub type lnEdge = cty::c_uint;
pub type lnExtiCallback =
    ::core::option::Option<unsafe extern "C" fn(pin: lnPin, cookie: *mut cty::c_void)>;
extern "C" {
    #[link_name = "\u{1}_Z21lnExtiAttachInterrupti6lnEdgePFviPvES0_"]
    pub fn lnExtiAttachInterrupt(
        pin: lnPin,
        edge: lnEdge,
        cb: lnExtiCallback,
        cookie: *mut cty::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z21lnExtiDetachInterrupti"]
    pub fn lnExtiDetachInterrupt(pin: lnPin);
}
extern "C" {
    #[link_name = "\u{1}_Z21lnExtiEnableInterrupti"]
    pub fn lnExtiEnableInterrupt(pin: lnPin);
}
extern "C" {
    #[link_name = "\u{1}_Z22lnExtiDisableInterrupti"]
    pub fn lnExtiDisableInterrupt(pin: lnPin);
}
extern "C" {
    #[link_name = "\u{1}_Z7pinModehh"]
    pub fn pinMode(pin: u8, b: u8);
}
extern "C" {
    #[link_name = "\u{1}_Z12digitalWritehh"]
    pub fn digitalWrite(pin: u8, val: u8);
}
extern "C" {
    #[link_name = "\u{1}_Z13digitalToggleh"]
    pub fn digitalToggle(pin: u8);
}
extern "C" {
    #[link_name = "\u{1}_Z11digitalReadh"]
    pub fn digitalRead(pin: u8) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Z10analogReadh"]
    pub fn analogRead(pin: u8) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Z11analogWritehi"]
    pub fn analogWrite(pin: u8, val: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_Z15attachInterrupthPFvvEi"]
    pub fn attachInterrupt(
        interruptNum: u8,
        userFunc: ::core::option::Option<unsafe extern "C" fn()>,
        mode: cty::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_Z15detachInterrupth"]
    pub fn detachInterrupt(interruptNum: u8);
}
extern "C" {
    #[link_name = "\u{1}_Z6millisv"]
    pub fn millis() -> u64;
}
extern "C" {
    #[link_name = "\u{1}_Z6microsv"]
    pub fn micros() -> u64;
}
extern "C" {
    #[link_name = "\u{1}_Z5delayi"]
    pub fn delay(ms: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_Z17delayMicrosecondsi"]
    pub fn delayMicroseconds(us: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_Z12noInterruptsv"]
    pub fn noInterrupts();
}
extern "C" {
    #[link_name = "\u{1}_Z10interruptsv"]
    pub fn interrupts();
}
extern "C" {
    pub fn deadEnd(code: cty::c_int);
}
extern "C" {
    pub fn vPortEnterCritical();
}
extern "C" {
    pub fn vPortExitCritical();
}
extern "C" {
    pub static mut SystemCoreClock: cty::c_ulong;
}
extern "C" {
    pub fn do_assert(a: *const cty::c_char);
}
pub type TaskFunction_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>;
pub type StackType_t = cty::c_ulong;
pub type BaseType_t = cty::c_long;
pub type UBaseType_t = cty::c_ulong;
pub type TickType_t = cty::c_ulong;
extern "C" {
    pub fn vPortSuppressTicksAndSleep(xExpectedIdleTime: TickType_t);
}
extern "C" {
    pub fn vPortValidateInterruptPriority();
}
extern "C" {
    pub fn pxPortInitialiseStack(
        pxTopOfStack: *mut StackType_t,
        pxCode: TaskFunction_t,
        pvParameters: *mut cty::c_void,
    ) -> *mut StackType_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HeapRegion {
    pub pucStartAddress: *mut u8,
    pub xSizeInBytes: size_t,
}
pub type HeapRegion_t = HeapRegion;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xHeapStats {
    pub xAvailableHeapSpaceInBytes: size_t,
    pub xSizeOfLargestFreeBlockInBytes: size_t,
    pub xSizeOfSmallestFreeBlockInBytes: size_t,
    pub xNumberOfFreeBlocks: size_t,
    pub xMinimumEverFreeBytesRemaining: size_t,
    pub xNumberOfSuccessfulAllocations: size_t,
    pub xNumberOfSuccessfulFrees: size_t,
}
pub type HeapStats_t = xHeapStats;
extern "C" {
    pub fn vPortDefineHeapRegions(pxHeapRegions: *const HeapRegion_t);
}
extern "C" {
    pub fn vPortGetHeapStats(pxHeapStats: *mut HeapStats_t);
}
extern "C" {
    pub fn pvPortMalloc(xSize: size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn vPortFree(pv: *mut cty::c_void);
}
extern "C" {
    pub fn vPortInitialiseBlocks();
}
extern "C" {
    pub fn xPortGetFreeHeapSize() -> size_t;
}
extern "C" {
    pub fn xPortGetMinimumEverFreeHeapSize() -> size_t;
}
extern "C" {
    pub fn xPortStartScheduler() -> BaseType_t;
}
extern "C" {
    pub fn vPortEndScheduler();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST_ITEM {
    pub xDummy2: TickType_t,
    pub pvDummy3: [*mut cty::c_void; 4usize],
}
pub type StaticListItem_t = xSTATIC_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_MINI_LIST_ITEM {
    pub xDummy2: TickType_t,
    pub pvDummy3: [*mut cty::c_void; 2usize],
}
pub type StaticMiniListItem_t = xSTATIC_MINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_LIST {
    pub uxDummy2: UBaseType_t,
    pub pvDummy3: *mut cty::c_void,
    pub xDummy4: StaticMiniListItem_t,
}
pub type StaticList_t = xSTATIC_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TCB {
    pub pxDummy1: *mut cty::c_void,
    pub xDummy3: [StaticListItem_t; 2usize],
    pub uxDummy5: UBaseType_t,
    pub pxDummy6: *mut cty::c_void,
    pub ucDummy7: [u8; 16usize],
    pub uxDummy10: [UBaseType_t; 2usize],
    pub uxDummy12: [UBaseType_t; 2usize],
    pub ulDummy18: [cty::c_ulong; 5usize],
    pub ucDummy19: [u8; 5usize],
}
pub type StaticTask_t = xSTATIC_TCB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xSTATIC_QUEUE {
    pub pvDummy1: [*mut cty::c_void; 3usize],
    pub u: xSTATIC_QUEUE__bindgen_ty_1,
    pub xDummy3: [StaticList_t; 2usize],
    pub uxDummy4: [UBaseType_t; 3usize],
    pub ucDummy5: [u8; 2usize],
    pub uxDummy8: UBaseType_t,
    pub ucDummy9: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xSTATIC_QUEUE__bindgen_ty_1 {
    pub pvDummy2: *mut cty::c_void,
    pub uxDummy2: UBaseType_t,
}
pub type StaticQueue_t = xSTATIC_QUEUE;
pub type StaticSemaphore_t = StaticQueue_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_EVENT_GROUP {
    pub xDummy1: TickType_t,
    pub xDummy2: StaticList_t,
    pub uxDummy3: UBaseType_t,
}
pub type StaticEventGroup_t = xSTATIC_EVENT_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_TIMER {
    pub pvDummy1: *mut cty::c_void,
    pub xDummy2: StaticListItem_t,
    pub xDummy3: TickType_t,
    pub pvDummy5: *mut cty::c_void,
    pub pvDummy6: TaskFunction_t,
    pub uxDummy7: UBaseType_t,
    pub ucDummy8: u8,
}
pub type StaticTimer_t = xSTATIC_TIMER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xSTATIC_STREAM_BUFFER {
    pub uxDummy1: [size_t; 4usize],
    pub pvDummy2: [*mut cty::c_void; 3usize],
    pub ucDummy3: u8,
    pub uxDummy4: UBaseType_t,
}
pub type StaticStreamBuffer_t = xSTATIC_STREAM_BUFFER;
pub type StaticMessageBuffer_t = StaticStreamBuffer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
    pub pvOwner: *mut cty::c_void,
    pub pvContainer: *mut xLIST,
}
pub type ListItem_t = xLIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMINI_LIST_ITEM {
    pub xItemValue: TickType_t,
    pub pxNext: *mut xLIST_ITEM,
    pub pxPrevious: *mut xLIST_ITEM,
}
pub type MiniListItem_t = xMINI_LIST_ITEM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xLIST {
    pub uxNumberOfItems: UBaseType_t,
    pub pxIndex: *mut ListItem_t,
    pub xListEnd: MiniListItem_t,
}
pub type List_t = xLIST;
extern "C" {
    pub fn vListInitialise(pxList: *mut List_t);
}
extern "C" {
    pub fn vListInitialiseItem(pxItem: *mut ListItem_t);
}
extern "C" {
    pub fn vListInsert(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
    pub fn vListInsertEnd(pxList: *mut List_t, pxNewListItem: *mut ListItem_t);
}
extern "C" {
    pub fn uxListRemove(pxItemToRemove: *mut ListItem_t) -> UBaseType_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tskTaskControlBlock {
    _unused: [u8; 0],
}
pub type TaskHandle_t = *mut tskTaskControlBlock;
pub type TaskHookFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void) -> BaseType_t>;
pub const eTaskState_eRunning: eTaskState = 0;
pub const eTaskState_eReady: eTaskState = 1;
pub const eTaskState_eBlocked: eTaskState = 2;
pub const eTaskState_eSuspended: eTaskState = 3;
pub const eTaskState_eDeleted: eTaskState = 4;
pub const eTaskState_eInvalid: eTaskState = 5;
pub type eTaskState = cty::c_uint;
pub const eNotifyAction_eNoAction: eNotifyAction = 0;
pub const eNotifyAction_eSetBits: eNotifyAction = 1;
pub const eNotifyAction_eIncrement: eNotifyAction = 2;
pub const eNotifyAction_eSetValueWithOverwrite: eNotifyAction = 3;
pub const eNotifyAction_eSetValueWithoutOverwrite: eNotifyAction = 4;
pub type eNotifyAction = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTIME_OUT {
    pub xOverflowCount: BaseType_t,
    pub xTimeOnEntering: TickType_t,
}
pub type TimeOut_t = xTIME_OUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xMEMORY_REGION {
    pub pvBaseAddress: *mut cty::c_void,
    pub ulLengthInBytes: cty::c_ulong,
    pub ulParameters: cty::c_ulong,
}
pub type MemoryRegion_t = xMEMORY_REGION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_PARAMETERS {
    pub pvTaskCode: TaskFunction_t,
    pub pcName: *const cty::c_char,
    pub usStackDepth: u16,
    pub pvParameters: *mut cty::c_void,
    pub uxPriority: UBaseType_t,
    pub puxStackBuffer: *mut StackType_t,
    pub xRegions: [MemoryRegion_t; 1usize],
}
pub type TaskParameters_t = xTASK_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xTASK_STATUS {
    pub xHandle: TaskHandle_t,
    pub pcTaskName: *const cty::c_char,
    pub xTaskNumber: UBaseType_t,
    pub eCurrentState: eTaskState,
    pub uxCurrentPriority: UBaseType_t,
    pub uxBasePriority: UBaseType_t,
    pub ulRunTimeCounter: cty::c_ulong,
    pub pxStackBase: *mut StackType_t,
    pub usStackHighWaterMark: u16,
}
pub type TaskStatus_t = xTASK_STATUS;
pub const eSleepModeStatus_eAbortSleep: eSleepModeStatus = 0;
pub const eSleepModeStatus_eStandardSleep: eSleepModeStatus = 1;
pub const eSleepModeStatus_eNoTasksWaitingTimeout: eSleepModeStatus = 2;
pub type eSleepModeStatus = cty::c_uint;
extern "C" {
    pub fn xTaskCreate(
        pxTaskCode: TaskFunction_t,
        pcName: *const cty::c_char,
        usStackDepth: u16,
        pvParameters: *mut cty::c_void,
        uxPriority: UBaseType_t,
        pxCreatedTask: *mut TaskHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskAllocateMPURegions(xTask: TaskHandle_t, pxRegions: *const MemoryRegion_t);
}
extern "C" {
    pub fn vTaskDelete(xTaskToDelete: TaskHandle_t);
}
extern "C" {
    pub fn vTaskDelay(xTicksToDelay: TickType_t);
}
extern "C" {
    pub fn xTaskDelayUntil(
        pxPreviousWakeTime: *mut TickType_t,
        xTimeIncrement: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskAbortDelay(xTask: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn uxTaskPriorityGet(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn uxTaskPriorityGetFromISR(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn eTaskGetState(xTask: TaskHandle_t) -> eTaskState;
}
extern "C" {
    pub fn vTaskGetInfo(
        xTask: TaskHandle_t,
        pxTaskStatus: *mut TaskStatus_t,
        xGetFreeStackSpace: BaseType_t,
        eState: eTaskState,
    );
}
extern "C" {
    pub fn vTaskPrioritySet(xTask: TaskHandle_t, uxNewPriority: UBaseType_t);
}
extern "C" {
    pub fn vTaskSuspend(xTaskToSuspend: TaskHandle_t);
}
extern "C" {
    pub fn vTaskResume(xTaskToResume: TaskHandle_t);
}
extern "C" {
    pub fn xTaskResumeFromISR(xTaskToResume: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskStartScheduler();
}
extern "C" {
    pub fn vTaskEndScheduler();
}
extern "C" {
    pub fn vTaskSuspendAll();
}
extern "C" {
    pub fn xTaskResumeAll() -> BaseType_t;
}
extern "C" {
    pub fn xTaskGetTickCount() -> TickType_t;
}
extern "C" {
    pub fn xTaskGetTickCountFromISR() -> TickType_t;
}
extern "C" {
    pub fn uxTaskGetNumberOfTasks() -> UBaseType_t;
}
extern "C" {
    pub fn pcTaskGetName(xTaskToQuery: TaskHandle_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn xTaskGetHandle(pcNameToQuery: *const cty::c_char) -> TaskHandle_t;
}
extern "C" {
    pub fn uxTaskGetStackHighWaterMark(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn uxTaskGetStackHighWaterMark2(xTask: TaskHandle_t) -> u16;
}
extern "C" {
    pub fn vApplicationStackOverflowHook(xTask: TaskHandle_t, pcTaskName: *mut cty::c_char);
}
extern "C" {
    pub fn vApplicationTickHook();
}
extern "C" {
    pub fn xTaskCallApplicationTaskHook(
        xTask: TaskHandle_t,
        pvParameter: *mut cty::c_void,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskGetIdleTaskHandle() -> TaskHandle_t;
}
extern "C" {
    pub fn uxTaskGetSystemState(
        pxTaskStatusArray: *mut TaskStatus_t,
        uxArraySize: UBaseType_t,
        pulTotalRunTime: *mut cty::c_ulong,
    ) -> UBaseType_t;
}
extern "C" {
    pub fn vTaskList(pcWriteBuffer: *mut cty::c_char);
}
extern "C" {
    pub fn vTaskGetRunTimeStats(pcWriteBuffer: *mut cty::c_char);
}
extern "C" {
    pub fn ulTaskGetIdleRunTimeCounter() -> cty::c_ulong;
}
extern "C" {
    pub fn xTaskGenericNotify(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        ulValue: cty::c_ulong,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut cty::c_ulong,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskGenericNotifyFromISR(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        ulValue: cty::c_ulong,
        eAction: eNotifyAction,
        pulPreviousNotificationValue: *mut cty::c_ulong,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskGenericNotifyWait(
        uxIndexToWaitOn: UBaseType_t,
        ulBitsToClearOnEntry: cty::c_ulong,
        ulBitsToClearOnExit: cty::c_ulong,
        pulNotificationValue: *mut cty::c_ulong,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTaskGenericNotifyGiveFromISR(
        xTaskToNotify: TaskHandle_t,
        uxIndexToNotify: UBaseType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    );
}
extern "C" {
    pub fn ulTaskGenericNotifyTake(
        uxIndexToWaitOn: UBaseType_t,
        xClearCountOnExit: BaseType_t,
        xTicksToWait: TickType_t,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn xTaskGenericNotifyStateClear(
        xTask: TaskHandle_t,
        uxIndexToClear: UBaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn ulTaskGenericNotifyValueClear(
        xTask: TaskHandle_t,
        uxIndexToClear: UBaseType_t,
        ulBitsToClear: cty::c_ulong,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn vTaskSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
extern "C" {
    pub fn xTaskCheckForTimeOut(
        pxTimeOut: *mut TimeOut_t,
        pxTicksToWait: *mut TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTaskCatchUpTicks(xTicksToCatchUp: TickType_t) -> BaseType_t;
}
extern "C" {
    pub fn xTaskIncrementTick() -> BaseType_t;
}
extern "C" {
    pub fn vTaskPlaceOnEventList(pxEventList: *mut List_t, xTicksToWait: TickType_t);
}
extern "C" {
    pub fn vTaskPlaceOnUnorderedEventList(
        pxEventList: *mut List_t,
        xItemValue: TickType_t,
        xTicksToWait: TickType_t,
    );
}
extern "C" {
    pub fn vTaskPlaceOnEventListRestricted(
        pxEventList: *mut List_t,
        xTicksToWait: TickType_t,
        xWaitIndefinitely: BaseType_t,
    );
}
extern "C" {
    pub fn xTaskRemoveFromEventList(pxEventList: *const List_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskRemoveFromUnorderedEventList(
        pxEventListItem: *mut ListItem_t,
        xItemValue: TickType_t,
    );
}
extern "C" {
    pub fn vTaskSwitchContext();
}
extern "C" {
    pub fn uxTaskResetEventItemValue() -> TickType_t;
}
extern "C" {
    pub fn xTaskGetCurrentTaskHandle() -> TaskHandle_t;
}
extern "C" {
    pub fn vTaskMissedYield();
}
extern "C" {
    pub fn xTaskGetSchedulerState() -> BaseType_t;
}
extern "C" {
    pub fn xTaskPriorityInherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xTaskPriorityDisinherit(pxMutexHolder: TaskHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn vTaskPriorityDisinheritAfterTimeout(
        pxMutexHolder: TaskHandle_t,
        uxHighestPriorityWaitingTask: UBaseType_t,
    );
}
extern "C" {
    pub fn uxTaskGetTaskNumber(xTask: TaskHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn vTaskSetTaskNumber(xTask: TaskHandle_t, uxHandle: UBaseType_t);
}
extern "C" {
    pub fn vTaskStepTick(xTicksToJump: TickType_t);
}
extern "C" {
    pub fn eTaskConfirmSleepModeStatus() -> eSleepModeStatus;
}
extern "C" {
    pub fn pvTaskIncrementMutexHeldCount() -> TaskHandle_t;
}
extern "C" {
    pub fn vTaskInternalSetTimeOutState(pxTimeOut: *mut TimeOut_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct QueueDefinition {
    _unused: [u8; 0],
}
pub type QueueHandle_t = *mut QueueDefinition;
pub type QueueSetHandle_t = *mut QueueDefinition;
pub type QueueSetMemberHandle_t = *mut QueueDefinition;
extern "C" {
    pub fn xQueueGenericSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const cty::c_void,
        xTicksToWait: TickType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueuePeek(
        xQueue: QueueHandle_t,
        pvBuffer: *mut cty::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueuePeekFromISR(xQueue: QueueHandle_t, pvBuffer: *mut cty::c_void) -> BaseType_t;
}
extern "C" {
    pub fn xQueueReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut cty::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn uxQueueMessagesWaiting(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn uxQueueSpacesAvailable(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn vQueueDelete(xQueue: QueueHandle_t);
}
extern "C" {
    pub fn xQueueGenericSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const cty::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xCopyPosition: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGiveFromISR(
        xQueue: QueueHandle_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut cty::c_void,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueIsQueueEmptyFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueIsQueueFullFromISR(xQueue: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn uxQueueMessagesWaitingFromISR(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn xQueueCRSendFromISR(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const cty::c_void,
        xCoRoutinePreviouslyWoken: BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRReceiveFromISR(
        xQueue: QueueHandle_t,
        pvBuffer: *mut cty::c_void,
        pxTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRSend(
        xQueue: QueueHandle_t,
        pvItemToQueue: *const cty::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCRReceive(
        xQueue: QueueHandle_t,
        pvBuffer: *mut cty::c_void,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueCreateMutex(ucQueueType: u8) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateMutexStatic(
        ucQueueType: u8,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphore(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateCountingSemaphoreStatic(
        uxMaxCount: UBaseType_t,
        uxInitialCount: UBaseType_t,
        pxStaticQueue: *mut StaticQueue_t,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueSemaphoreTake(xQueue: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGetMutexHolder(xSemaphore: QueueHandle_t) -> TaskHandle_t;
}
extern "C" {
    pub fn xQueueGetMutexHolderFromISR(xSemaphore: QueueHandle_t) -> TaskHandle_t;
}
extern "C" {
    pub fn xQueueTakeMutexRecursive(xMutex: QueueHandle_t, xTicksToWait: TickType_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGiveMutexRecursive(xMutex: QueueHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xQueueGenericCreate(
        uxQueueLength: UBaseType_t,
        uxItemSize: UBaseType_t,
        ucQueueType: u8,
    ) -> QueueHandle_t;
}
extern "C" {
    pub fn xQueueCreateSet(uxEventQueueLength: UBaseType_t) -> QueueSetHandle_t;
}
extern "C" {
    pub fn xQueueAddToSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueRemoveFromSet(
        xQueueOrSemaphore: QueueSetMemberHandle_t,
        xQueueSet: QueueSetHandle_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xQueueSelectFromSet(
        xQueueSet: QueueSetHandle_t,
        xTicksToWait: TickType_t,
    ) -> QueueSetMemberHandle_t;
}
extern "C" {
    pub fn xQueueSelectFromSetFromISR(xQueueSet: QueueSetHandle_t) -> QueueSetMemberHandle_t;
}
extern "C" {
    pub fn vQueueWaitForMessageRestricted(
        xQueue: QueueHandle_t,
        xTicksToWait: TickType_t,
        xWaitIndefinitely: BaseType_t,
    );
}
extern "C" {
    pub fn xQueueGenericReset(xQueue: QueueHandle_t, xNewQueue: BaseType_t) -> BaseType_t;
}
extern "C" {
    pub fn vQueueSetQueueNumber(xQueue: QueueHandle_t, uxQueueNumber: UBaseType_t);
}
extern "C" {
    pub fn uxQueueGetQueueNumber(xQueue: QueueHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn ucQueueGetQueueType(xQueue: QueueHandle_t) -> u8;
}
pub type SemaphoreHandle_t = QueueHandle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tmrTimerControl {
    _unused: [u8; 0],
}
pub type TimerHandle_t = *mut tmrTimerControl;
pub type TimerCallbackFunction_t =
    ::core::option::Option<unsafe extern "C" fn(xTimer: TimerHandle_t)>;
pub type PendedFunction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: cty::c_ulong)>;
extern "C" {
    pub fn xTimerCreate(
        pcTimerName: *const cty::c_char,
        xTimerPeriodInTicks: TickType_t,
        uxAutoReload: UBaseType_t,
        pvTimerID: *mut cty::c_void,
        pxCallbackFunction: TimerCallbackFunction_t,
    ) -> TimerHandle_t;
}
extern "C" {
    pub fn pvTimerGetTimerID(xTimer: TimerHandle_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn vTimerSetTimerID(xTimer: TimerHandle_t, pvNewID: *mut cty::c_void);
}
extern "C" {
    pub fn xTimerIsTimerActive(xTimer: TimerHandle_t) -> BaseType_t;
}
extern "C" {
    pub fn xTimerGetTimerDaemonTaskHandle() -> TaskHandle_t;
}
extern "C" {
    pub fn xTimerPendFunctionCallFromISR(
        xFunctionToPend: PendedFunction_t,
        pvParameter1: *mut cty::c_void,
        ulParameter2: cty::c_ulong,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xTimerPendFunctionCall(
        xFunctionToPend: PendedFunction_t,
        pvParameter1: *mut cty::c_void,
        ulParameter2: cty::c_ulong,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn pcTimerGetName(xTimer: TimerHandle_t) -> *const cty::c_char;
}
extern "C" {
    pub fn vTimerSetReloadMode(xTimer: TimerHandle_t, uxAutoReload: UBaseType_t);
}
extern "C" {
    pub fn uxTimerGetReloadMode(xTimer: TimerHandle_t) -> UBaseType_t;
}
extern "C" {
    pub fn xTimerGetPeriod(xTimer: TimerHandle_t) -> TickType_t;
}
extern "C" {
    pub fn xTimerGetExpiryTime(xTimer: TimerHandle_t) -> TickType_t;
}
extern "C" {
    pub fn xTimerCreateTimerTask() -> BaseType_t;
}
extern "C" {
    pub fn xTimerGenericCommand(
        xTimer: TimerHandle_t,
        xCommandID: BaseType_t,
        xOptionalValue: TickType_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
        xTicksToWait: TickType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn vTimerSetTimerNumber(xTimer: TimerHandle_t, uxTimerNumber: UBaseType_t);
}
extern "C" {
    pub fn uxTimerGetTimerNumber(xTimer: TimerHandle_t) -> UBaseType_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EventGroupDef_t {
    _unused: [u8; 0],
}
pub type EventGroupHandle_t = *mut EventGroupDef_t;
pub type EventBits_t = TickType_t;
extern "C" {
    pub fn xEventGroupCreate() -> EventGroupHandle_t;
}
extern "C" {
    pub fn xEventGroupWaitBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToWaitFor: EventBits_t,
        xClearOnExit: BaseType_t,
        xWaitForAllBits: BaseType_t,
        xTicksToWait: TickType_t,
    ) -> EventBits_t;
}
extern "C" {
    pub fn xEventGroupClearBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToClear: EventBits_t,
    ) -> EventBits_t;
}
extern "C" {
    pub fn xEventGroupClearBitsFromISR(
        xEventGroup: EventGroupHandle_t,
        uxBitsToClear: EventBits_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xEventGroupSetBits(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
    ) -> EventBits_t;
}
extern "C" {
    pub fn xEventGroupSetBitsFromISR(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
        pxHigherPriorityTaskWoken: *mut BaseType_t,
    ) -> BaseType_t;
}
extern "C" {
    pub fn xEventGroupSync(
        xEventGroup: EventGroupHandle_t,
        uxBitsToSet: EventBits_t,
        uxBitsToWaitFor: EventBits_t,
        xTicksToWait: TickType_t,
    ) -> EventBits_t;
}
extern "C" {
    pub fn xEventGroupGetBitsFromISR(xEventGroup: EventGroupHandle_t) -> EventBits_t;
}
extern "C" {
    pub fn vEventGroupDelete(xEventGroup: EventGroupHandle_t);
}
extern "C" {
    pub fn vEventGroupSetBitsCallback(pvEventGroup: *mut cty::c_void, ulBitsToSet: cty::c_ulong);
}
extern "C" {
    pub fn vEventGroupClearBitsCallback(
        pvEventGroup: *mut cty::c_void,
        ulBitsToClear: cty::c_ulong,
    );
}
extern "C" {
    pub fn uxEventGroupGetNumber(xEventGroup: *mut cty::c_void) -> UBaseType_t;
}
extern "C" {
    pub fn vEventGroupSetNumber(xEventGroup: *mut cty::c_void, uxEventGroupNumber: UBaseType_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lnBinarySemaphore {
    pub _handle: SemaphoreHandle_t,
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBinarySemaphore4takeEv"]
    pub fn lnBinarySemaphore_take(this: *mut lnBinarySemaphore) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBinarySemaphore7tryTakeEv"]
    pub fn lnBinarySemaphore_tryTake(this: *mut lnBinarySemaphore) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBinarySemaphore4takeEi"]
    pub fn lnBinarySemaphore_take1(this: *mut lnBinarySemaphore, timeoutMs: cty::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBinarySemaphore4giveEv"]
    pub fn lnBinarySemaphore_give(this: *mut lnBinarySemaphore) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBinarySemaphoreC1Ev"]
    pub fn lnBinarySemaphore_lnBinarySemaphore(this: *mut lnBinarySemaphore);
}
impl lnBinarySemaphore {
    #[inline]
    pub unsafe fn take(&mut self) -> bool {
        lnBinarySemaphore_take(self)
    }
    #[inline]
    pub unsafe fn tryTake(&mut self) -> bool {
        lnBinarySemaphore_tryTake(self)
    }
    #[inline]
    pub unsafe fn take1(&mut self, timeoutMs: cty::c_int) -> bool {
        lnBinarySemaphore_take1(self, timeoutMs)
    }
    #[inline]
    pub unsafe fn give(&mut self) -> bool {
        lnBinarySemaphore_give(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnBinarySemaphore_lnBinarySemaphore(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct lnTask__bindgen_vtable(cty::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct lnTask {
    pub vtable_: *const lnTask__bindgen_vtable,
    pub _taskHandle: TaskHandle_t,
    pub _name: *const cty::c_char,
    pub _priority: cty::c_int,
    pub _taskSize: cty::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN6lnTask5startEv"]
    pub fn lnTask_start(this: *mut lnTask);
}
extern "C" {
    #[link_name = "\u{1}_ZN6lnTaskC2EPKcii"]
    pub fn lnTask_lnTask(
        this: *mut lnTask,
        name: *const cty::c_char,
        priority: cty::c_int,
        taskSize: cty::c_int,
    );
}
impl lnTask {
    #[inline]
    pub unsafe fn start(&mut self) {
        lnTask_start(self)
    }
    #[inline]
    pub unsafe fn new(
        name: *const cty::c_char,
        priority: cty::c_int,
        taskSize: cty::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnTask_lnTask(__bindgen_tmp.as_mut_ptr(), name, priority, taskSize);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN6lnTaskD1Ev"]
    pub fn lnTask_lnTask_destructor(this: *mut lnTask);
}
#[repr(C)]
pub struct lnEventGroup__bindgen_vtable(cty::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct lnEventGroup {
    pub vtable_: *const lnEventGroup__bindgen_vtable,
    pub _handle: EventGroupHandle_t,
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnEventGroup9setEventsEm"]
    pub fn lnEventGroup_setEvents(this: *mut lnEventGroup, events: cty::c_ulong);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnEventGroup10waitEventsEmi"]
    pub fn lnEventGroup_waitEvents(
        this: *mut lnEventGroup,
        maskint: cty::c_ulong,
        timeout: cty::c_int,
    ) -> cty::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnEventGroup10readEventsEm"]
    pub fn lnEventGroup_readEvents(this: *mut lnEventGroup, maskInt: cty::c_ulong) -> cty::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnEventGroupC1Ev"]
    pub fn lnEventGroup_lnEventGroup(this: *mut lnEventGroup);
}
impl lnEventGroup {
    #[inline]
    pub unsafe fn setEvents(&mut self, events: cty::c_ulong) {
        lnEventGroup_setEvents(self, events)
    }
    #[inline]
    pub unsafe fn waitEvents(
        &mut self,
        maskint: cty::c_ulong,
        timeout: cty::c_int,
    ) -> cty::c_ulong {
        lnEventGroup_waitEvents(self, maskint, timeout)
    }
    #[inline]
    pub unsafe fn readEvents(&mut self, maskInt: cty::c_ulong) -> cty::c_ulong {
        lnEventGroup_readEvents(self, maskInt)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnEventGroup_lnEventGroup(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnEventGroupD1Ev"]
    pub fn lnEventGroup_lnEventGroup_destructor(this: *mut lnEventGroup);
}
#[repr(C)]
pub struct lnFastEventGroup__bindgen_vtable(cty::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct lnFastEventGroup {
    pub vtable_: *const lnFastEventGroup__bindgen_vtable,
    pub _value: cty::c_ulong,
    pub _mask: cty::c_ulong,
    pub _waitingTask: TaskHandle_t,
}
extern "C" {
    #[link_name = "\u{1}_ZN16lnFastEventGroup13takeOwnershipEv"]
    pub fn lnFastEventGroup_takeOwnership(this: *mut lnFastEventGroup);
}
extern "C" {
    #[link_name = "\u{1}_ZN16lnFastEventGroup9setEventsEm"]
    pub fn lnFastEventGroup_setEvents(this: *mut lnFastEventGroup, events: cty::c_ulong);
}
extern "C" {
    #[link_name = "\u{1}_ZN16lnFastEventGroup10waitEventsEmi"]
    pub fn lnFastEventGroup_waitEvents(
        this: *mut lnFastEventGroup,
        maskint: cty::c_ulong,
        timeout: cty::c_int,
    ) -> cty::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_ZN16lnFastEventGroup10readEventsEm"]
    pub fn lnFastEventGroup_readEvents(
        this: *mut lnFastEventGroup,
        maskInt: cty::c_ulong,
    ) -> cty::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_ZN16lnFastEventGroupC1Ev"]
    pub fn lnFastEventGroup_lnFastEventGroup(this: *mut lnFastEventGroup);
}
impl lnFastEventGroup {
    #[inline]
    pub unsafe fn takeOwnership(&mut self) {
        lnFastEventGroup_takeOwnership(self)
    }
    #[inline]
    pub unsafe fn setEvents(&mut self, events: cty::c_ulong) {
        lnFastEventGroup_setEvents(self, events)
    }
    #[inline]
    pub unsafe fn waitEvents(
        &mut self,
        maskint: cty::c_ulong,
        timeout: cty::c_int,
    ) -> cty::c_ulong {
        lnFastEventGroup_waitEvents(self, maskint, timeout)
    }
    #[inline]
    pub unsafe fn readEvents(&mut self, maskInt: cty::c_ulong) -> cty::c_ulong {
        lnFastEventGroup_readEvents(self, maskInt)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnFastEventGroup_lnFastEventGroup(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN16lnFastEventGroupD1Ev"]
    pub fn lnFastEventGroup_lnFastEventGroup_destructor(this: *mut lnFastEventGroup);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lnMutex {
    pub _handle: SemaphoreHandle_t,
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnMutex4lockEv"]
    pub fn lnMutex_lock(this: *mut lnMutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnMutex6unlockEv"]
    pub fn lnMutex_unlock(this: *mut lnMutex) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnMutexC1Ev"]
    pub fn lnMutex_lnMutex(this: *mut lnMutex);
}
impl lnMutex {
    #[inline]
    pub unsafe fn lock(&mut self) -> bool {
        lnMutex_lock(self)
    }
    #[inline]
    pub unsafe fn unlock(&mut self) -> bool {
        lnMutex_unlock(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnMutex_lnMutex(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct lnAutoMutex {
    pub _tex: *mut lnMutex,
}
extern "C" {
    #[link_name = "\u{1}_Z10LoggerInitv"]
    pub fn LoggerInit();
}
extern "C" {
    #[link_name = "\u{1}_Z11debugLoggerPKcz"]
    pub fn debugLogger(fmt: *const cty::c_char, ...);
}
extern "C" {
    pub fn Logger(fmt: *const cty::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}_Z17lnInitSystemClockv"]
    pub fn lnInitSystemClock();
}
pub const Peripherals_pNONE: Peripherals = 0;
pub const Peripherals_pSPI0: Peripherals = 1;
pub const Peripherals_pSPI1: Peripherals = 2;
pub const Peripherals_pSPI2: Peripherals = 3;
pub const Peripherals_pUART0: Peripherals = 4;
pub const Peripherals_pUART1: Peripherals = 5;
pub const Peripherals_pUART2: Peripherals = 6;
pub const Peripherals_pUART3: Peripherals = 7;
pub const Peripherals_pUART4: Peripherals = 8;
pub const Peripherals_pI2C0: Peripherals = 9;
pub const Peripherals_pI2C1: Peripherals = 10;
pub const Peripherals_pCAN0: Peripherals = 11;
pub const Peripherals_pCAN1: Peripherals = 12;
pub const Peripherals_pDAC: Peripherals = 13;
pub const Peripherals_pPMU: Peripherals = 14;
pub const Peripherals_pBKPI: Peripherals = 15;
pub const Peripherals_pWWDGT: Peripherals = 16;
pub const Peripherals_pTIMER0: Peripherals = 17;
pub const Peripherals_pTIMER1: Peripherals = 18;
pub const Peripherals_pTIMER2: Peripherals = 19;
pub const Peripherals_pTIMER3: Peripherals = 20;
pub const Peripherals_pTIMER4: Peripherals = 21;
pub const Peripherals_pTIMER5: Peripherals = 22;
pub const Peripherals_pTIMER6: Peripherals = 23;
pub const Peripherals_pUSB: Peripherals = 24;
pub const Peripherals_pADC0: Peripherals = 25;
pub const Peripherals_pADC1: Peripherals = 26;
pub const Peripherals_pGPIOA: Peripherals = 27;
pub const Peripherals_pGPIOB: Peripherals = 28;
pub const Peripherals_pGPIOC: Peripherals = 29;
pub const Peripherals_pGPIOD: Peripherals = 30;
pub const Peripherals_pGPIOE: Peripherals = 31;
pub const Peripherals_pAF: Peripherals = 32;
pub const Peripherals_pDMA0: Peripherals = 33;
pub const Peripherals_pDMA1: Peripherals = 34;
pub const Peripherals_pAPB1: Peripherals = 100;
pub const Peripherals_pAPB2: Peripherals = 101;
pub const Peripherals_pSYSCLOCK: Peripherals = 102;
pub type Peripherals = cty::c_uint;
pub const lnADC_DIVIDER_lnADC_CLOCK_DIV_BY_2: lnADC_DIVIDER = 0;
pub const lnADC_DIVIDER_lnADC_CLOCK_DIV_BY_4: lnADC_DIVIDER = 1;
pub const lnADC_DIVIDER_lnADC_CLOCK_DIV_BY_6: lnADC_DIVIDER = 2;
pub const lnADC_DIVIDER_lnADC_CLOCK_DIV_BY_8: lnADC_DIVIDER = 3;
pub const lnADC_DIVIDER_lnADC_CLOCK_DIV_BY_12: lnADC_DIVIDER = 5;
pub const lnADC_DIVIDER_lnADC_CLOCK_DIV_BY_16: lnADC_DIVIDER = 7;
pub type lnADC_DIVIDER = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lnPeripherals {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN13lnPeripherals5resetE11Peripherals"]
    pub fn lnPeripherals_reset(periph: Peripherals);
}
extern "C" {
    #[link_name = "\u{1}_ZN13lnPeripherals6enableE11Peripherals"]
    pub fn lnPeripherals_enable(periph: Peripherals);
}
extern "C" {
    #[link_name = "\u{1}_ZN13lnPeripherals7disableE11Peripherals"]
    pub fn lnPeripherals_disable(periph: Peripherals);
}
extern "C" {
    #[link_name = "\u{1}_ZN13lnPeripherals8getClockE11Peripherals"]
    pub fn lnPeripherals_getClock(periph: Peripherals) -> cty::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_ZN13lnPeripherals13setAdcDividerE13lnADC_DIVIDER"]
    pub fn lnPeripherals_setAdcDivider(divider: lnADC_DIVIDER);
}
extern "C" {
    #[link_name = "\u{1}_ZN13lnPeripherals14enableUsb48MhzEv"]
    pub fn lnPeripherals_enableUsb48Mhz();
}
impl lnPeripherals {
    #[inline]
    pub unsafe fn reset(periph: Peripherals) {
        lnPeripherals_reset(periph)
    }
    #[inline]
    pub unsafe fn enable(periph: Peripherals) {
        lnPeripherals_enable(periph)
    }
    #[inline]
    pub unsafe fn disable(periph: Peripherals) {
        lnPeripherals_disable(periph)
    }
    #[inline]
    pub unsafe fn getClock(periph: Peripherals) -> cty::c_ulong {
        lnPeripherals_getClock(periph)
    }
    #[inline]
    pub unsafe fn setAdcDivider(divider: lnADC_DIVIDER) {
        lnPeripherals_setAdcDivider(divider)
    }
    #[inline]
    pub unsafe fn enableUsb48Mhz() {
        lnPeripherals_enableUsb48Mhz()
    }
}
pub const LnIRQ_LN_IRQ_MSIP: LnIRQ = -13;
pub const LnIRQ_LN_IRQ_NONE: LnIRQ = -13;
pub const LnIRQ_LN_IRQ_RESET: LnIRQ = -12;
pub const LnIRQ_LN_IRQ_NMI: LnIRQ = -11;
pub const LnIRQ_LN_IRQ_HARDFAULT: LnIRQ = -10;
pub const LnIRQ_LN_IRQ_MEMMANAGE: LnIRQ = -9;
pub const LnIRQ_LN_IRQ_BUSFAULT: LnIRQ = -8;
pub const LnIRQ_LN_IRQ_USAGEFAULT: LnIRQ = -7;
pub const LnIRQ_LN_IRQ_RESERVED: LnIRQ = -6;
pub const LnIRQ_LN_IRQ_SVCALL: LnIRQ = -5;
pub const LnIRQ_LN_IRQ_DEBUGMON: LnIRQ = -4;
pub const LnIRQ_LN_IRQ_RESERVED2: LnIRQ = -3;
pub const LnIRQ_LN_IRQ_PENDSV: LnIRQ = -2;
pub const LnIRQ_LN_IRQ_SYSTICK: LnIRQ = -1;
pub const LnIRQ_LN_IRQ_WWDG: LnIRQ = 0;
pub const LnIRQ_LN_IRQ_LVD: LnIRQ = 1;
pub const LnIRQ_LN_IRQ_TAMPER: LnIRQ = 2;
pub const LnIRQ_LN_IRQ_RTC: LnIRQ = 3;
pub const LnIRQ_LN_IRQ_FMC: LnIRQ = 4;
pub const LnIRQ_LN_IRQ_RCU_RCC: LnIRQ = 5;
pub const LnIRQ_LN_IRQ_EXTI0: LnIRQ = 6;
pub const LnIRQ_LN_IRQ_EXTI1: LnIRQ = 7;
pub const LnIRQ_LN_IRQ_EXTI2: LnIRQ = 8;
pub const LnIRQ_LN_IRQ_EXTI3: LnIRQ = 9;
pub const LnIRQ_LN_IRQ_EXTI4: LnIRQ = 10;
pub const LnIRQ_LN_IRQ_DMA0_Channel0: LnIRQ = 11;
pub const LnIRQ_LN_IRQ_DMA0_Channel1: LnIRQ = 12;
pub const LnIRQ_LN_IRQ_DMA0_Channel2: LnIRQ = 13;
pub const LnIRQ_LN_IRQ_DMA0_Channel3: LnIRQ = 14;
pub const LnIRQ_LN_IRQ_DMA0_Channel4: LnIRQ = 15;
pub const LnIRQ_LN_IRQ_DMA0_Channel5: LnIRQ = 16;
pub const LnIRQ_LN_IRQ_DMA0_Channel6: LnIRQ = 17;
pub const LnIRQ_LN_IRQ_ADC0_1: LnIRQ = 18;
pub const LnIRQ_LN_IRQ_USB_HP_CAN_TX: LnIRQ = 19;
pub const LnIRQ_LN_IRQ_USB_LP_CAN_RX0: LnIRQ = 20;
pub const LnIRQ_LN_IRQ_CAN_RX1: LnIRQ = 21;
pub const LnIRQ_LN_IRQ_CAN_SCE: LnIRQ = 22;
pub const LnIRQ_LN_IRQ_EXTI5_9: LnIRQ = 23;
pub const LnIRQ_LN_IRQ_TIMER0_BRK: LnIRQ = 24;
pub const LnIRQ_LN_IRQ_TIMER0_UP: LnIRQ = 25;
pub const LnIRQ_LN_IRQ_TIMER0_TRG_CMT: LnIRQ = 26;
pub const LnIRQ_LN_IRQ_TIMER0_Channel: LnIRQ = 27;
pub const LnIRQ_LN_IRQ_TIMER1: LnIRQ = 28;
pub const LnIRQ_LN_IRQ_TIMER2: LnIRQ = 29;
pub const LnIRQ_LN_IRQ_TIMER3: LnIRQ = 30;
pub const LnIRQ_LN_IRQ_I2C0_EV: LnIRQ = 31;
pub const LnIRQ_LN_IRQ_I2C0_ER: LnIRQ = 32;
pub const LnIRQ_LN_IRQ_I2C1_EV: LnIRQ = 33;
pub const LnIRQ_LN_IRQ_I2C1_ER: LnIRQ = 34;
pub const LnIRQ_LN_IRQ_SPI0: LnIRQ = 35;
pub const LnIRQ_LN_IRQ_SPI1: LnIRQ = 36;
pub const LnIRQ_LN_IRQ_USART0: LnIRQ = 37;
pub const LnIRQ_LN_IRQ_USART1: LnIRQ = 38;
pub const LnIRQ_LN_IRQ_USART2: LnIRQ = 39;
pub const LnIRQ_LN_IRQ_EXTI10_15: LnIRQ = 40;
pub const LnIRQ_LN_IRQ_RTCALARM: LnIRQ = 41;
pub const LnIRQ_LN_IRQ_USBWAKEUP: LnIRQ = 42;
pub const LnIRQ_LN_IRQ_TIMER7_BRK_TIMER12: LnIRQ = 43;
pub const LnIRQ_LN_IRQ_TIMER7_UP_TIMER13: LnIRQ = 44;
pub const LnIRQ_LN_IRQ_TIMER7_TRG_COM_TIMER14: LnIRQ = 45;
pub const LnIRQ_LN_IRQ_TIMER7_CC: LnIRQ = 46;
pub const LnIRQ_LN_IRQ_ADC2: LnIRQ = 47;
pub const LnIRQ_LN_IRQ_FSMC: LnIRQ = 48;
pub const LnIRQ_LN_IRQ_SDIO: LnIRQ = 49;
pub const LnIRQ_LN_IRQ_TIMER4: LnIRQ = 50;
pub const LnIRQ_LN_IRQ_SPI2: LnIRQ = 51;
pub const LnIRQ_LN_IRQ_UART3: LnIRQ = 52;
pub const LnIRQ_LN_IRQ_UART4: LnIRQ = 53;
pub const LnIRQ_LN_IRQ_TIMER5: LnIRQ = 54;
pub const LnIRQ_LN_IRQ_TIMER6: LnIRQ = 55;
pub const LnIRQ_LN_IRQ_DMA1_Channel0: LnIRQ = 56;
pub const LnIRQ_LN_IRQ_DMA1_Channel1: LnIRQ = 57;
pub const LnIRQ_LN_IRQ_DMA1_Channel2: LnIRQ = 58;
pub const LnIRQ_LN_IRQ_DMA1_Channel3: LnIRQ = 59;
pub const LnIRQ_LN_IRQ_DMA1_Channel4: LnIRQ = 60;
pub const LnIRQ_LN_IRQ_ARM_LAST: LnIRQ = 61;
pub type LnIRQ = cty::c_int;
pub type lnInterruptHandler = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}_Z17lnEnableInterruptRK5LnIRQ"]
    pub fn lnEnableInterrupt(irq: *const LnIRQ);
}
extern "C" {
    #[link_name = "\u{1}_Z18lnDisableInterruptRK5LnIRQ"]
    pub fn lnDisableInterrupt(irq: *const LnIRQ);
}
extern "C" {
    #[link_name = "\u{1}_Z21lnSetInterruptHandlerRK5LnIRQPFvvE"]
    pub fn lnSetInterruptHandler(irq: *const LnIRQ, handler: lnInterruptHandler);
}
extern "C" {
    #[link_name = "\u{1}_Z16lnIrqSetPriorityRK5LnIRQi"]
    pub fn lnIrqSetPriority(irq: *const LnIRQ, prio: cty::c_int);
}
extern "C" {
    pub fn _putchar(character: cty::c_char);
}
extern "C" {
    pub fn printf_(format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn sprintf_(buffer: *mut cty::c_char, format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn snprintf_(
        buffer: *mut cty::c_char,
        count: size_t,
        format: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsnprintf_(
        buffer: *mut cty::c_char,
        count: size_t,
        format: *const cty::c_char,
        va: va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vprintf_(format: *const cty::c_char, va: va_list) -> cty::c_int;
}
extern "C" {
    pub fn fctprintf(
        out: ::core::option::Option<
            unsafe extern "C" fn(character: cty::c_char, arg: *mut cty::c_void),
        >,
        arg: *mut cty::c_void,
        format: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}_Z7lnGetUsv"]
    pub fn lnGetUs() -> cty::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_Z9lnGetUs64v"]
    pub fn lnGetUs64() -> u64;
}
extern "C" {
    #[link_name = "\u{1}_Z9lnDelayUsi"]
    pub fn lnDelayUs(wait: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_Z7lnDelayi"]
    pub fn lnDelay(wait: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_Z7lnGetMsv"]
    pub fn lnGetMs() -> cty::c_ulong;
}
extern "C" {
    pub fn free(a: *mut cty::c_void);
}
extern "C" {
    pub fn malloc(size: size_t) -> *mut cty::c_void;
}
#[repr(C)]
#[derive(Debug)]
pub struct lnDMA {
    pub _dma: cty::c_ulong,
    pub _channelInt: cty::c_int,
    pub _dmaInt: cty::c_int,
    pub _type: lnDMA_DmaTransferType,
    pub _irq: LnIRQ,
    pub _cb: lnDMA_doneCallback,
    pub _cookie: *mut cty::c_void,
    pub _control: cty::c_ulong,
    pub _priority: cty::c_ulong,
    pub _sourceWidth: cty::c_int,
    pub _targetWidth: cty::c_int,
}
pub const lnDMA_DmaInterruptType_DMA_INTERRUPT_HALF: lnDMA_DmaInterruptType = 0;
pub const lnDMA_DmaInterruptType_DMA_INTERRUPT_FULL: lnDMA_DmaInterruptType = 1;
pub type lnDMA_DmaInterruptType = cty::c_uint;
pub type lnDMA_doneCallback = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: lnDMA_DmaInterruptType),
>;
pub const lnDMA_DmaTransferType_DMA_MEMORY_TO_PERIPH: lnDMA_DmaTransferType = 0;
pub const lnDMA_DmaTransferType_DMA_PERIPH_TO_MEMORY: lnDMA_DmaTransferType = 1;
pub type lnDMA_DmaTransferType = cty::c_uint;
pub const lnDMA_DmaPriority_DMA_PRIORITY_LOW: lnDMA_DmaPriority = 0;
pub const lnDMA_DmaPriority_DMA_PRIORITY_NORMAL: lnDMA_DmaPriority = 1;
pub const lnDMA_DmaPriority_DMA_PRIORITY_HIGH: lnDMA_DmaPriority = 2;
pub const lnDMA_DmaPriority_DMA_PRIORITY_ULTRA_HIGH: lnDMA_DmaPriority = 3;
pub type lnDMA_DmaPriority = cty::c_uint;
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA14attachCallbackEPFvPvNS_16DmaInterruptTypeEES0_"]
    pub fn lnDMA_attachCallback(this: *mut lnDMA, cb: lnDMA_doneCallback, cookie: *mut cty::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA14detachCallbackEv"]
    pub fn lnDMA_detachCallback(this: *mut lnDMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA34doMemoryToPeripheralTransferNoLockEiPKtS1_bbb"]
    pub fn lnDMA_doMemoryToPeripheralTransferNoLock(
        this: *mut lnDMA,
        count: cty::c_int,
        source: *const u16,
        target: *const u16,
        repeat: bool,
        circularMode: bool,
        bothInterrutps: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA34doPeripheralToMemoryTransferNoLockEiPKtS1_bb"]
    pub fn lnDMA_doPeripheralToMemoryTransferNoLock(
        this: *mut lnDMA,
        count: cty::c_int,
        target: *const u16,
        source: *const u16,
        circularMode: bool,
        bothInterrutps: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA16setInterruptMaskEbb"]
    pub fn lnDMA_setInterruptMask(this: *mut lnDMA, full: bool, half: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA11setPriorityENS_11DmaPriorityE"]
    pub fn lnDMA_setPriority(this: *mut lnDMA, prio: lnDMA_DmaPriority);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA13beginTransferEv"]
    pub fn lnDMA_beginTransfer(this: *mut lnDMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA15getCurrentCountEv"]
    pub fn lnDMA_getCurrentCount(this: *mut lnDMA) -> cty::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA11endTransferEv"]
    pub fn lnDMA_endTransfer(this: *mut lnDMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA14cancelTransferEv"]
    pub fn lnDMA_cancelTransfer(this: *mut lnDMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA11setWordSizeEii"]
    pub fn lnDMA_setWordSize(
        this: *mut lnDMA,
        sourceWordSize: cty::c_int,
        targetWordSize: cty::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA14invokeCallbackEv"]
    pub fn lnDMA_invokeCallback(this: *mut lnDMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA5pauseEv"]
    pub fn lnDMA_pause(this: *mut lnDMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMA6resumeEv"]
    pub fn lnDMA_resume(this: *mut lnDMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMAC1ENS_15DmaTransferTypeEiiii"]
    pub fn lnDMA_lnDMA(
        this: *mut lnDMA,
        type_: lnDMA_DmaTransferType,
        dmaEngine: cty::c_int,
        dmaChannel: cty::c_int,
        sourceWith: cty::c_int,
        targetWidth: cty::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDMAD1Ev"]
    pub fn lnDMA_lnDMA_destructor(this: *mut lnDMA);
}
impl lnDMA {
    #[inline]
    pub unsafe fn attachCallback(&mut self, cb: lnDMA_doneCallback, cookie: *mut cty::c_void) {
        lnDMA_attachCallback(self, cb, cookie)
    }
    #[inline]
    pub unsafe fn detachCallback(&mut self) {
        lnDMA_detachCallback(self)
    }
    #[inline]
    pub unsafe fn doMemoryToPeripheralTransferNoLock(
        &mut self,
        count: cty::c_int,
        source: *const u16,
        target: *const u16,
        repeat: bool,
        circularMode: bool,
        bothInterrutps: bool,
    ) -> bool {
        lnDMA_doMemoryToPeripheralTransferNoLock(
            self,
            count,
            source,
            target,
            repeat,
            circularMode,
            bothInterrutps,
        )
    }
    #[inline]
    pub unsafe fn doPeripheralToMemoryTransferNoLock(
        &mut self,
        count: cty::c_int,
        target: *const u16,
        source: *const u16,
        circularMode: bool,
        bothInterrutps: bool,
    ) -> bool {
        lnDMA_doPeripheralToMemoryTransferNoLock(
            self,
            count,
            target,
            source,
            circularMode,
            bothInterrutps,
        )
    }
    #[inline]
    pub unsafe fn setInterruptMask(&mut self, full: bool, half: bool) -> bool {
        lnDMA_setInterruptMask(self, full, half)
    }
    #[inline]
    pub unsafe fn setPriority(&mut self, prio: lnDMA_DmaPriority) {
        lnDMA_setPriority(self, prio)
    }
    #[inline]
    pub unsafe fn beginTransfer(&mut self) {
        lnDMA_beginTransfer(self)
    }
    #[inline]
    pub unsafe fn getCurrentCount(&mut self) -> cty::c_ulong {
        lnDMA_getCurrentCount(self)
    }
    #[inline]
    pub unsafe fn endTransfer(&mut self) {
        lnDMA_endTransfer(self)
    }
    #[inline]
    pub unsafe fn cancelTransfer(&mut self) {
        lnDMA_cancelTransfer(self)
    }
    #[inline]
    pub unsafe fn setWordSize(&mut self, sourceWordSize: cty::c_int, targetWordSize: cty::c_int) {
        lnDMA_setWordSize(self, sourceWordSize, targetWordSize)
    }
    #[inline]
    pub unsafe fn invokeCallback(&mut self) {
        lnDMA_invokeCallback(self)
    }
    #[inline]
    pub unsafe fn pause(&mut self) {
        lnDMA_pause(self)
    }
    #[inline]
    pub unsafe fn resume(&mut self) {
        lnDMA_resume(self)
    }
    #[inline]
    pub unsafe fn new(
        type_: lnDMA_DmaTransferType,
        dmaEngine: cty::c_int,
        dmaChannel: cty::c_int,
        sourceWith: cty::c_int,
        targetWidth: cty::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnDMA_lnDMA(
            __bindgen_tmp.as_mut_ptr(),
            type_,
            dmaEngine,
            dmaChannel,
            sourceWith,
            targetWidth,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        lnDMA_lnDMA_destructor(self)
    }
}
pub const lnADC_CYCLES_LN_ADC_SMPT_1_5: lnADC_CYCLES = 0;
pub const lnADC_CYCLES_LN_ADC_SMPT_7_5: lnADC_CYCLES = 1;
pub const lnADC_CYCLES_LN_ADC_SMPT_13_5: lnADC_CYCLES = 2;
pub const lnADC_CYCLES_LN_ADC_SMPT_28_5: lnADC_CYCLES = 3;
pub const lnADC_CYCLES_LN_ADC_SMPT_41_5: lnADC_CYCLES = 4;
pub const lnADC_CYCLES_LN_ADC_SMPT_55_5: lnADC_CYCLES = 5;
pub const lnADC_CYCLES_LN_ADC_SMPT_71_5: lnADC_CYCLES = 6;
pub const lnADC_CYCLES_LN_ADC_SMPT_239_5: lnADC_CYCLES = 7;
pub type lnADC_CYCLES = cty::c_uint;
#[repr(C)]
pub struct lnBaseAdc__bindgen_vtable(cty::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct lnBaseAdc {
    pub vtable_: *const lnBaseAdc__bindgen_vtable,
    pub _instance: cty::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN9lnBaseAdc7getVrefEv"]
    pub fn lnBaseAdc_getVref(this: *mut lnBaseAdc) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN9lnBaseAdc6getVccEv"]
    pub fn lnBaseAdc_getVcc() -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN9lnBaseAdc7setSmptE12lnADC_CYCLES"]
    pub fn lnBaseAdc_setSmpt(this: *mut lnBaseAdc, cycles: lnADC_CYCLES);
}
extern "C" {
    #[link_name = "\u{1}_ZN9lnBaseAdc7readVccEv"]
    pub fn lnBaseAdc_readVcc(this: *mut lnBaseAdc);
}
extern "C" {
    #[link_name = "\u{1}_ZN9lnBaseAdc10adcChannelEi"]
    pub fn lnBaseAdc_adcChannel(pin: lnPin) -> cty::c_int;
}
impl lnBaseAdc {
    #[inline]
    pub unsafe fn getVref(&mut self) -> cty::c_int {
        lnBaseAdc_getVref(self)
    }
    #[inline]
    pub unsafe fn getVcc() -> f32 {
        lnBaseAdc_getVcc()
    }
    #[inline]
    pub unsafe fn setSmpt(&mut self, cycles: lnADC_CYCLES) {
        lnBaseAdc_setSmpt(self, cycles)
    }
    #[inline]
    pub unsafe fn readVcc(&mut self) {
        lnBaseAdc_readVcc(self)
    }
    #[inline]
    pub unsafe fn adcChannel(pin: lnPin) -> cty::c_int {
        lnBaseAdc_adcChannel(pin)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN9lnBaseAdc5setupEv"]
    pub fn lnBaseAdc_setup(this: *mut cty::c_void);
}
#[repr(C)]
#[derive(Debug)]
pub struct lnSimpleADC {
    pub _base: lnBaseAdc,
    pub _pin: cty::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADC3pinEv"]
    pub fn lnSimpleADC_pin(this: *mut lnSimpleADC) -> lnPin;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADC6setPinEi"]
    pub fn lnSimpleADC_setPin(this: *mut lnSimpleADC, pin: lnPin) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADC10simpleReadEv"]
    pub fn lnSimpleADC_simpleRead(this: *mut lnSimpleADC) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADC16pollingMultiReadEiPiPt"]
    pub fn lnSimpleADC_pollingMultiRead(
        this: *mut lnSimpleADC,
        nbPins: cty::c_int,
        pins: *mut lnPin,
        output: *mut u16,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADC7getVrefEv"]
    pub fn lnSimpleADC_getVref(this: *mut lnSimpleADC) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADC6getVccEv"]
    pub fn lnSimpleADC_getVcc() -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADC7readVccEv"]
    pub fn lnSimpleADC_readVcc(this: *mut lnSimpleADC);
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADCC1Eii"]
    pub fn lnSimpleADC_lnSimpleADC(this: *mut lnSimpleADC, instance: cty::c_int, pin: lnPin);
}
impl lnSimpleADC {
    #[inline]
    pub unsafe fn pin(&mut self) -> lnPin {
        lnSimpleADC_pin(self)
    }
    #[inline]
    pub unsafe fn setPin(&mut self, pin: lnPin) -> bool {
        lnSimpleADC_setPin(self, pin)
    }
    #[inline]
    pub unsafe fn simpleRead(&mut self) -> cty::c_int {
        lnSimpleADC_simpleRead(self)
    }
    #[inline]
    pub unsafe fn pollingMultiRead(
        &mut self,
        nbPins: cty::c_int,
        pins: *mut lnPin,
        output: *mut u16,
    ) -> bool {
        lnSimpleADC_pollingMultiRead(self, nbPins, pins, output)
    }
    #[inline]
    pub unsafe fn getVref(&mut self) -> cty::c_int {
        lnSimpleADC_getVref(self)
    }
    #[inline]
    pub unsafe fn getVcc() -> f32 {
        lnSimpleADC_getVcc()
    }
    #[inline]
    pub unsafe fn readVcc(&mut self) {
        lnSimpleADC_readVcc(self)
    }
    #[inline]
    pub unsafe fn new(instance: cty::c_int, pin: lnPin) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnSimpleADC_lnSimpleADC(__bindgen_tmp.as_mut_ptr(), instance, pin);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADCD1Ev"]
    pub fn lnSimpleADC_lnSimpleADC_destructor(this: *mut lnSimpleADC);
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnSimpleADC5setupEv"]
    pub fn lnSimpleADC_setup(this: *mut cty::c_void);
}
#[repr(C)]
#[derive(Debug)]
pub struct lnTimingAdc {
    pub _base: lnBaseAdc,
    pub _timer: cty::c_int,
    pub _channel: cty::c_int,
    pub _fq: cty::c_int,
    pub _dma: lnDMA,
    pub _dmaSem: lnBinarySemaphore,
    pub _adcTimer: *mut lnAdcTimer,
    pub _nbPins: cty::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnTimingAdc9setSourceEiiiiPKi"]
    pub fn lnTimingAdc_setSource(
        this: *mut lnTimingAdc,
        timer: cty::c_int,
        channel: cty::c_int,
        fq: cty::c_int,
        nbPins: cty::c_int,
        pins: *const lnPin,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnTimingAdc9multiReadEiPt"]
    pub fn lnTimingAdc_multiRead(
        this: *mut lnTimingAdc,
        nbSamplePerChannel: cty::c_int,
        output: *mut u16,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnTimingAdc8dmaDone_EPvN5lnDMA16DmaInterruptTypeE"]
    pub fn lnTimingAdc_dmaDone_(foo: *mut cty::c_void, typ: lnDMA_DmaInterruptType);
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnTimingAdc7dmaDoneEv"]
    pub fn lnTimingAdc_dmaDone(this: *mut lnTimingAdc);
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnTimingAdcC1Ei"]
    pub fn lnTimingAdc_lnTimingAdc(this: *mut lnTimingAdc, instance: cty::c_int);
}
impl lnTimingAdc {
    #[inline]
    pub unsafe fn setSource(
        &mut self,
        timer: cty::c_int,
        channel: cty::c_int,
        fq: cty::c_int,
        nbPins: cty::c_int,
        pins: *const lnPin,
    ) -> bool {
        lnTimingAdc_setSource(self, timer, channel, fq, nbPins, pins)
    }
    #[inline]
    pub unsafe fn multiRead(&mut self, nbSamplePerChannel: cty::c_int, output: *mut u16) -> bool {
        lnTimingAdc_multiRead(self, nbSamplePerChannel, output)
    }
    #[inline]
    pub unsafe fn dmaDone_(foo: *mut cty::c_void, typ: lnDMA_DmaInterruptType) {
        lnTimingAdc_dmaDone_(foo, typ)
    }
    #[inline]
    pub unsafe fn dmaDone(&mut self) {
        lnTimingAdc_dmaDone(self)
    }
    #[inline]
    pub unsafe fn new(instance: cty::c_int) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnTimingAdc_lnTimingAdc(__bindgen_tmp.as_mut_ptr(), instance);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnTimingAdcD1Ev"]
    pub fn lnTimingAdc_lnTimingAdc_destructor(this: *mut lnTimingAdc);
}
pub type lnBasicTimerIrq = ::core::option::Option<unsafe extern "C" fn(cookie: *mut cty::c_void)>;
#[repr(C)]
pub struct lnBasicTimer__bindgen_vtable(cty::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct lnBasicTimer {
    pub vtable_: *const lnBasicTimer__bindgen_vtable,
    pub _timer: cty::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnBasicTimer17setTimerFrequencyEi"]
    pub fn lnBasicTimer_setTimerFrequency(this: *mut lnBasicTimer, fqInHz: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnBasicTimer17setTimerFrequencyEii"]
    pub fn lnBasicTimer_setTimerFrequency1(
        this: *mut lnBasicTimer,
        prediv: cty::c_int,
        reload: cty::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnBasicTimer17getTimerFrequencyEv"]
    pub fn lnBasicTimer_getTimerFrequency(this: *mut lnBasicTimer) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnBasicTimer7disableEv"]
    pub fn lnBasicTimer_disable(this: *mut lnBasicTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnBasicTimer6enableEv"]
    pub fn lnBasicTimer_enable(this: *mut lnBasicTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnBasicTimerC1Ei"]
    pub fn lnBasicTimer_lnBasicTimer(this: *mut lnBasicTimer, timer: cty::c_int);
}
impl lnBasicTimer {
    #[inline]
    pub unsafe fn setTimerFrequency(&mut self, fqInHz: cty::c_int) {
        lnBasicTimer_setTimerFrequency(self, fqInHz)
    }
    #[inline]
    pub unsafe fn setTimerFrequency1(&mut self, prediv: cty::c_int, reload: cty::c_int) {
        lnBasicTimer_setTimerFrequency1(self, prediv, reload)
    }
    #[inline]
    pub unsafe fn getTimerFrequency(&mut self) -> cty::c_int {
        lnBasicTimer_getTimerFrequency(self)
    }
    #[inline]
    pub unsafe fn disable(&mut self) {
        lnBasicTimer_disable(self)
    }
    #[inline]
    pub unsafe fn enable(&mut self) {
        lnBasicTimer_enable(self)
    }
    #[inline]
    pub unsafe fn new(timer: cty::c_int) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnBasicTimer_lnBasicTimer(__bindgen_tmp.as_mut_ptr(), timer);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnBasicTimerD1Ev"]
    pub fn lnBasicTimer_lnBasicTimer_destructor(this: *mut lnBasicTimer);
}
#[repr(C)]
#[derive(Debug)]
pub struct lnBasicDelayTimer {
    pub _base: lnBasicTimer,
    pub _handler: lnBasicTimerIrq,
    pub _cookie: *mut cty::c_void,
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBasicDelayTimer3armEi"]
    pub fn lnBasicDelayTimer_arm(this: *mut lnBasicDelayTimer, delayUs: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBasicDelayTimer12setInterruptEPFvPvES0_"]
    pub fn lnBasicDelayTimer_setInterrupt(
        this: *mut lnBasicDelayTimer,
        handler: lnBasicTimerIrq,
        cookie: *mut cty::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBasicDelayTimer16interruptHandlerEi"]
    pub fn lnBasicDelayTimer_interruptHandler(timer: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBasicDelayTimer3irqEv"]
    pub fn lnBasicDelayTimer_irq(this: *mut lnBasicDelayTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBasicDelayTimer15enableInterruptEv"]
    pub fn lnBasicDelayTimer_enableInterrupt(this: *mut lnBasicDelayTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBasicDelayTimer16disableInterruptEv"]
    pub fn lnBasicDelayTimer_disableInterrupt(this: *mut lnBasicDelayTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBasicDelayTimerC1Ei"]
    pub fn lnBasicDelayTimer_lnBasicDelayTimer(this: *mut lnBasicDelayTimer, timer: cty::c_int);
}
impl lnBasicDelayTimer {
    #[inline]
    pub unsafe fn arm(&mut self, delayUs: cty::c_int) {
        lnBasicDelayTimer_arm(self, delayUs)
    }
    #[inline]
    pub unsafe fn setInterrupt(&mut self, handler: lnBasicTimerIrq, cookie: *mut cty::c_void) {
        lnBasicDelayTimer_setInterrupt(self, handler, cookie)
    }
    #[inline]
    pub unsafe fn interruptHandler(timer: cty::c_int) {
        lnBasicDelayTimer_interruptHandler(timer)
    }
    #[inline]
    pub unsafe fn irq(&mut self) {
        lnBasicDelayTimer_irq(self)
    }
    #[inline]
    pub unsafe fn enableInterrupt(&mut self) {
        lnBasicDelayTimer_enableInterrupt(self)
    }
    #[inline]
    pub unsafe fn disableInterrupt(&mut self) {
        lnBasicDelayTimer_disableInterrupt(self)
    }
    #[inline]
    pub unsafe fn new(timer: cty::c_int) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnBasicDelayTimer_lnBasicDelayTimer(__bindgen_tmp.as_mut_ptr(), timer);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN17lnBasicDelayTimerD1Ev"]
    pub fn lnBasicDelayTimer_lnBasicDelayTimer_destructor(this: *mut lnBasicDelayTimer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lnCpuID {
    pub _address: u8,
}
pub const lnCpuID_LN_VENDOR_LN_MCU_STM32: lnCpuID_LN_VENDOR = 0;
pub const lnCpuID_LN_VENDOR_LN_MCU_GD32: lnCpuID_LN_VENDOR = 1;
pub const lnCpuID_LN_VENDOR_LN_MCU_CH32: lnCpuID_LN_VENDOR = 2;
pub type lnCpuID_LN_VENDOR = cty::c_uint;
pub const lnCpuID_LN_MCU_LN_MCU_ARM_F3: lnCpuID_LN_MCU = 0;
pub const lnCpuID_LN_MCU_LN_MCU_ARM_F4: lnCpuID_LN_MCU = 1;
pub const lnCpuID_LN_MCU_LN_MCU_RISCV: lnCpuID_LN_MCU = 2;
pub type lnCpuID_LN_MCU = cty::c_uint;
extern "C" {
    #[link_name = "\u{1}_ZN7lnCpuID8identifyEv"]
    pub fn lnCpuID_identify();
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnCpuID6vendorEv"]
    pub fn lnCpuID_vendor() -> lnCpuID_LN_VENDOR;
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnCpuID3mcuEv"]
    pub fn lnCpuID_mcu() -> lnCpuID_LN_MCU;
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnCpuID11mcuAsStringEv"]
    pub fn lnCpuID_mcuAsString() -> *const cty::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnCpuID9flashSizeEv"]
    pub fn lnCpuID_flashSize() -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnCpuID7ramSizeEv"]
    pub fn lnCpuID_ramSize() -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnCpuID10idAsStringEv"]
    pub fn lnCpuID_idAsString() -> *const cty::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnCpuID10clockSpeedEv"]
    pub fn lnCpuID_clockSpeed() -> cty::c_int;
}
impl lnCpuID {
    #[inline]
    pub unsafe fn identify() {
        lnCpuID_identify()
    }
    #[inline]
    pub unsafe fn vendor() -> lnCpuID_LN_VENDOR {
        lnCpuID_vendor()
    }
    #[inline]
    pub unsafe fn mcu() -> lnCpuID_LN_MCU {
        lnCpuID_mcu()
    }
    #[inline]
    pub unsafe fn mcuAsString() -> *const cty::c_char {
        lnCpuID_mcuAsString()
    }
    #[inline]
    pub unsafe fn flashSize() -> cty::c_int {
        lnCpuID_flashSize()
    }
    #[inline]
    pub unsafe fn ramSize() -> cty::c_int {
        lnCpuID_ramSize()
    }
    #[inline]
    pub unsafe fn idAsString() -> *const cty::c_char {
        lnCpuID_idAsString()
    }
    #[inline]
    pub unsafe fn clockSpeed() -> cty::c_int {
        lnCpuID_clockSpeed()
    }
}
#[repr(C)]
pub struct lnDAC__bindgen_vtable(cty::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct lnDAC {
    pub vtable_: *const lnDAC__bindgen_vtable,
    pub _instance: cty::c_int,
    pub _dma: lnDMA,
    pub _timer: *mut lnBasicTimer,
    pub _dmaSem: lnBinarySemaphore,
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC3pinEv"]
    pub fn lnDAC_pin(this: *mut lnDAC) -> lnPin;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC6enableEv"]
    pub fn lnDAC_enable(this: *mut lnDAC);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC7disableEv"]
    pub fn lnDAC_disable(this: *mut lnDAC);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC10simpleModeEv"]
    pub fn lnDAC_simpleMode(this: *mut lnDAC);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC8setValueEi"]
    pub fn lnDAC_setValue(this: *mut lnDAC, value: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC12startDmaModeEi"]
    pub fn lnDAC_startDmaMode(this: *mut lnDAC, fq: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC11stopDmaModeEv"]
    pub fn lnDAC_stopDmaMode(this: *mut lnDAC);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC15getDmaFrequencyEv"]
    pub fn lnDAC_getDmaFrequency(this: *mut lnDAC) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC8dmaWriteEiPtb"]
    pub fn lnDAC_dmaWrite(this: *mut lnDAC, nbn: cty::c_int, data: *mut u16, loop_: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC8dmaDone_EPvN5lnDMA16DmaInterruptTypeE"]
    pub fn lnDAC_dmaDone_(t: *mut cty::c_void, typ: lnDMA_DmaInterruptType);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC7dmaDoneEv"]
    pub fn lnDAC_dmaDone(this: *mut lnDAC);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDAC16dmaWriteInternalEiPtb"]
    pub fn lnDAC_dmaWriteInternal(this: *mut lnDAC, nb: cty::c_int, data: *mut u16, loop_: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDACC1Ei"]
    pub fn lnDAC_lnDAC(this: *mut lnDAC, instance: cty::c_int);
}
impl lnDAC {
    #[inline]
    pub unsafe fn pin(&mut self) -> lnPin {
        lnDAC_pin(self)
    }
    #[inline]
    pub unsafe fn enable(&mut self) {
        lnDAC_enable(self)
    }
    #[inline]
    pub unsafe fn disable(&mut self) {
        lnDAC_disable(self)
    }
    #[inline]
    pub unsafe fn simpleMode(&mut self) {
        lnDAC_simpleMode(self)
    }
    #[inline]
    pub unsafe fn setValue(&mut self, value: cty::c_int) {
        lnDAC_setValue(self, value)
    }
    #[inline]
    pub unsafe fn startDmaMode(&mut self, fq: cty::c_int) {
        lnDAC_startDmaMode(self, fq)
    }
    #[inline]
    pub unsafe fn stopDmaMode(&mut self) {
        lnDAC_stopDmaMode(self)
    }
    #[inline]
    pub unsafe fn getDmaFrequency(&mut self) -> cty::c_int {
        lnDAC_getDmaFrequency(self)
    }
    #[inline]
    pub unsafe fn dmaWrite(&mut self, nbn: cty::c_int, data: *mut u16, loop_: bool) {
        lnDAC_dmaWrite(self, nbn, data, loop_)
    }
    #[inline]
    pub unsafe fn dmaDone_(t: *mut cty::c_void, typ: lnDMA_DmaInterruptType) {
        lnDAC_dmaDone_(t, typ)
    }
    #[inline]
    pub unsafe fn dmaDone(&mut self) {
        lnDAC_dmaDone(self)
    }
    #[inline]
    pub unsafe fn dmaWriteInternal(&mut self, nb: cty::c_int, data: *mut u16, loop_: bool) {
        lnDAC_dmaWriteInternal(self, nb, data, loop_)
    }
    #[inline]
    pub unsafe fn new(instance: cty::c_int) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnDAC_lnDAC(__bindgen_tmp.as_mut_ptr(), instance);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnDACD1Ev"]
    pub fn lnDAC_lnDAC_destructor(this: *mut lnDAC);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lnFMC {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnFMC5eraseEmi"]
    pub fn lnFMC_erase(startAddress: cty::c_ulong, sizeInKBytes: cty::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnFMC5writeEmPKhi"]
    pub fn lnFMC_write(
        startAddress: cty::c_ulong,
        data: *const u8,
        sizeInBytes: cty::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnFMC8eraseStmEmi"]
    pub fn lnFMC_eraseStm(startAddress: cty::c_ulong, sizeInKBytes: cty::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnFMC9eraseCh32Emi"]
    pub fn lnFMC_eraseCh32(startAddress: cty::c_ulong, sizeInKBytes: cty::c_int) -> bool;
}
impl lnFMC {
    #[inline]
    pub unsafe fn erase(startAddress: cty::c_ulong, sizeInKBytes: cty::c_int) -> bool {
        lnFMC_erase(startAddress, sizeInKBytes)
    }
    #[inline]
    pub unsafe fn write(
        startAddress: cty::c_ulong,
        data: *const u8,
        sizeInBytes: cty::c_int,
    ) -> bool {
        lnFMC_write(startAddress, data, sizeInBytes)
    }
    #[inline]
    pub unsafe fn eraseStm(startAddress: cty::c_ulong, sizeInKBytes: cty::c_int) -> bool {
        lnFMC_eraseStm(startAddress, sizeInKBytes)
    }
    #[inline]
    pub unsafe fn eraseCh32(startAddress: cty::c_ulong, sizeInKBytes: cty::c_int) -> bool {
        lnFMC_eraseCh32(startAddress, sizeInKBytes)
    }
}
#[repr(C)]
pub struct lnI2C__bindgen_vtable(cty::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct lnI2C {
    pub vtable_: *const lnI2C__bindgen_vtable,
    pub cookie: *mut cty::c_void,
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2C8setSpeedEi"]
    pub fn lnI2C_setSpeed(this: *mut lnI2C, speed: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2C10setAddressEi"]
    pub fn lnI2C_setAddress(this: *mut lnI2C, address: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2C5writeEiPh"]
    pub fn lnI2C_write(this: *mut lnI2C, n: cty::c_int, data: *mut u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2C4readEiPh"]
    pub fn lnI2C_read(this: *mut lnI2C, n: cty::c_int, data: *mut u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2C5writeEiiPh"]
    pub fn lnI2C_write1(this: *mut lnI2C, target: cty::c_int, n: cty::c_int, data: *mut u8)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2C10multiWriteEiiPiPPh"]
    pub fn lnI2C_multiWrite(
        this: *mut lnI2C,
        target: cty::c_int,
        nbSeqn: cty::c_int,
        seqLength: *mut cty::c_int,
        data: *mut *mut u8,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2C4readEiiPh"]
    pub fn lnI2C_read1(this: *mut lnI2C, target: cty::c_int, n: cty::c_int, data: *mut u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2C5beginEi"]
    pub fn lnI2C_begin(this: *mut lnI2C, target: cty::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2CC1Eii"]
    pub fn lnI2C_lnI2C(this: *mut lnI2C, instance: cty::c_int, speed: cty::c_int);
}
impl lnI2C {
    #[inline]
    pub unsafe fn setSpeed(&mut self, speed: cty::c_int) {
        lnI2C_setSpeed(self, speed)
    }
    #[inline]
    pub unsafe fn setAddress(&mut self, address: cty::c_int) {
        lnI2C_setAddress(self, address)
    }
    #[inline]
    pub unsafe fn write(&mut self, n: cty::c_int, data: *mut u8) -> bool {
        lnI2C_write(self, n, data)
    }
    #[inline]
    pub unsafe fn read(&mut self, n: cty::c_int, data: *mut u8) -> bool {
        lnI2C_read(self, n, data)
    }
    #[inline]
    pub unsafe fn write1(&mut self, target: cty::c_int, n: cty::c_int, data: *mut u8) -> bool {
        lnI2C_write1(self, target, n, data)
    }
    #[inline]
    pub unsafe fn multiWrite(
        &mut self,
        target: cty::c_int,
        nbSeqn: cty::c_int,
        seqLength: *mut cty::c_int,
        data: *mut *mut u8,
    ) -> bool {
        lnI2C_multiWrite(self, target, nbSeqn, seqLength, data)
    }
    #[inline]
    pub unsafe fn read1(&mut self, target: cty::c_int, n: cty::c_int, data: *mut u8) -> bool {
        lnI2C_read1(self, target, n, data)
    }
    #[inline]
    pub unsafe fn begin(&mut self, target: cty::c_int) -> bool {
        lnI2C_begin(self, target)
    }
    #[inline]
    pub unsafe fn new(instance: cty::c_int, speed: cty::c_int) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnI2C_lnI2C(__bindgen_tmp.as_mut_ptr(), instance, speed);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN5lnI2CD1Ev"]
    pub fn lnI2C_lnI2C_destructor(this: *mut lnI2C);
}
#[repr(C)]
#[derive(Debug)]
pub struct lnSerial {
    pub _instance: cty::c_int,
    pub _irq: LnIRQ,
    pub _adr: cty::c_ulong,
    pub _txMutex: lnMutex,
    pub _txDone: lnBinarySemaphore,
    pub _cur: *const u8,
    pub _tail: *const u8,
    pub _txState: lnSerial_txState,
    pub _txDma: lnDMA,
    pub _lastTransferSize: cty::c_int,
    pub _rxBufferSize: cty::c_int,
    pub _rxHead: cty::c_int,
    pub _rxTail: cty::c_int,
    pub _rxBuffer: *mut u8,
    pub _rxEnabled: bool,
    pub _rxError: cty::c_int,
    pub _cb: lnSerial_lnSerialCallback,
    pub _cbCookie: *mut cty::c_void,
}
pub const lnSerial_Event_dataAvailable: lnSerial_Event = 0;
pub type lnSerial_Event = cty::c_uint;
pub const lnSerial_txState_txTransmittingIdle: lnSerial_txState = 0;
pub const lnSerial_txState_txTransmittingInterrupt: lnSerial_txState = 1;
pub const lnSerial_txState_txTransmittingDMA: lnSerial_txState = 2;
pub const lnSerial_txState_txTransmittingLast: lnSerial_txState = 3;
pub type lnSerial_txState = cty::c_uint;
pub type lnSerial_lnSerialCallback =
    ::core::option::Option<unsafe extern "C" fn(cookie: *mut cty::c_void, event: lnSerial_Event)>;
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial4initEv"]
    pub fn lnSerial_init(this: *mut lnSerial) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial8setSpeedEi"]
    pub fn lnSerial_setSpeed(this: *mut lnSerial, speed: cty::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial8enableRxEb"]
    pub fn lnSerial_enableRx(this: *mut lnSerial, enabled: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial8transmitEiPKh"]
    pub fn lnSerial_transmit(this: *mut lnSerial, size: cty::c_int, buffer: *const u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial11dmaTransmitEiPKh"]
    pub fn lnSerial_dmaTransmit(this: *mut lnSerial, size: cty::c_int, buffer: *const u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial16disableInterruptEv"]
    pub fn lnSerial_disableInterrupt(this: *mut lnSerial);
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial15enableInterruptEb"]
    pub fn lnSerial_enableInterrupt(this: *mut lnSerial, txInterruptEnabled: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial7purgeRxEv"]
    pub fn lnSerial_purgeRx(this: *mut lnSerial);
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial10_interruptEv"]
    pub fn lnSerial__interrupt(this: *mut lnSerial);
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial4readEiPh"]
    pub fn lnSerial_read(this: *mut lnSerial, max: cty::c_int, to: *mut u8) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial14getReadPointerEPPh"]
    pub fn lnSerial_getReadPointer(this: *mut lnSerial, to: *mut *mut u8) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial7consumeEi"]
    pub fn lnSerial_consume(this: *mut lnSerial, n: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial10interruptsEi"]
    pub fn lnSerial_interrupts(instance: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial18txInterruptHandlerEv"]
    pub fn lnSerial_txInterruptHandler(this: *mut lnSerial);
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial18rxInterruptHandlerEv"]
    pub fn lnSerial_rxInterruptHandler(this: *mut lnSerial);
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial10_programTxEv"]
    pub fn lnSerial__programTx(this: *mut lnSerial) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial9_enableTxENS_7txStateE"]
    pub fn lnSerial__enableTx(this: *mut lnSerial, mode: lnSerial_txState) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial6moduloEi"]
    pub fn lnSerial_modulo(this: *mut lnSerial, in_: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial7txDmaCbEv"]
    pub fn lnSerial_txDmaCb(this: *mut lnSerial);
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerial12_dmaCallbackEPvN5lnDMA16DmaInterruptTypeE"]
    pub fn lnSerial__dmaCallback(c: *mut cty::c_void, it: lnDMA_DmaInterruptType);
}
extern "C" {
    #[link_name = "\u{1}_ZN8lnSerialC1Eii"]
    pub fn lnSerial_lnSerial(this: *mut lnSerial, instance: cty::c_int, rxBufferSize: cty::c_int);
}
impl lnSerial {
    #[inline]
    pub unsafe fn init(&mut self) -> bool {
        lnSerial_init(self)
    }
    #[inline]
    pub unsafe fn setSpeed(&mut self, speed: cty::c_int) -> bool {
        lnSerial_setSpeed(self, speed)
    }
    #[inline]
    pub unsafe fn enableRx(&mut self, enabled: bool) -> bool {
        lnSerial_enableRx(self, enabled)
    }
    #[inline]
    pub unsafe fn transmit(&mut self, size: cty::c_int, buffer: *const u8) -> bool {
        lnSerial_transmit(self, size, buffer)
    }
    #[inline]
    pub unsafe fn dmaTransmit(&mut self, size: cty::c_int, buffer: *const u8) -> bool {
        lnSerial_dmaTransmit(self, size, buffer)
    }
    #[inline]
    pub unsafe fn disableInterrupt(&mut self) {
        lnSerial_disableInterrupt(self)
    }
    #[inline]
    pub unsafe fn enableInterrupt(&mut self, txInterruptEnabled: bool) {
        lnSerial_enableInterrupt(self, txInterruptEnabled)
    }
    #[inline]
    pub unsafe fn purgeRx(&mut self) {
        lnSerial_purgeRx(self)
    }
    #[inline]
    pub unsafe fn _interrupt(&mut self) {
        lnSerial__interrupt(self)
    }
    #[inline]
    pub unsafe fn read(&mut self, max: cty::c_int, to: *mut u8) -> cty::c_int {
        lnSerial_read(self, max, to)
    }
    #[inline]
    pub unsafe fn getReadPointer(&mut self, to: *mut *mut u8) -> cty::c_int {
        lnSerial_getReadPointer(self, to)
    }
    #[inline]
    pub unsafe fn consume(&mut self, n: cty::c_int) {
        lnSerial_consume(self, n)
    }
    #[inline]
    pub unsafe fn interrupts(instance: cty::c_int) {
        lnSerial_interrupts(instance)
    }
    #[inline]
    pub unsafe fn txInterruptHandler(&mut self) {
        lnSerial_txInterruptHandler(self)
    }
    #[inline]
    pub unsafe fn rxInterruptHandler(&mut self) {
        lnSerial_rxInterruptHandler(self)
    }
    #[inline]
    pub unsafe fn _programTx(&mut self) -> bool {
        lnSerial__programTx(self)
    }
    #[inline]
    pub unsafe fn _enableTx(&mut self, mode: lnSerial_txState) -> bool {
        lnSerial__enableTx(self, mode)
    }
    #[inline]
    pub unsafe fn modulo(&mut self, in_: cty::c_int) -> cty::c_int {
        lnSerial_modulo(self, in_)
    }
    #[inline]
    pub unsafe fn txDmaCb(&mut self) {
        lnSerial_txDmaCb(self)
    }
    #[inline]
    pub unsafe fn _dmaCallback(c: *mut cty::c_void, it: lnDMA_DmaInterruptType) {
        lnSerial__dmaCallback(c, it)
    }
    #[inline]
    pub unsafe fn new(instance: cty::c_int, rxBufferSize: cty::c_int) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnSerial_lnSerial(__bindgen_tmp.as_mut_ptr(), instance, rxBufferSize);
        __bindgen_tmp.assume_init()
    }
}
pub const spiDataMode_SPI_MODE0: spiDataMode = 0;
pub const spiDataMode_SPI_MODE1: spiDataMode = 1;
pub const spiDataMode_SPI_MODE2: spiDataMode = 2;
pub const spiDataMode_SPI_MODE3: spiDataMode = 3;
pub type spiDataMode = cty::c_uint;
pub const spiBitOrder_SPI_LSBFIRST: spiBitOrder = 0;
pub const spiBitOrder_SPI_MSBFIRST: spiBitOrder = 1;
pub type spiBitOrder = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lnSPISettings {
    pub pinCS: cty::c_int,
    pub speed: cty::c_ulong,
    pub bOrder: spiBitOrder,
    pub dMode: spiDataMode,
}
pub type lnSpiCallback = ::core::option::Option<unsafe extern "C" fn(cookie: *mut cty::c_void)>;
#[repr(C)]
pub struct hwlnSPIClass__bindgen_vtable(cty::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct hwlnSPIClass {
    pub vtable_: *const hwlnSPIClass__bindgen_vtable,
    pub _internalSettings: lnSPISettings,
    pub _currentSetting: lnSPISettings,
    pub _settings: *mut lnSPISettings,
    pub _mutex: lnMutex,
    pub _done: lnBinarySemaphore,
    pub _useDMA: bool,
    pub _cookie: *mut cty::c_void,
    pub _callback: lnSpiCallback,
    pub _callbackCookie: *mut cty::c_void,
    pub _instance: cty::c_int,
    pub _adr: cty::c_ulong,
    pub _irq: LnIRQ,
    pub _inSession: bool,
    pub txDma: lnDMA,
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass5beginEv"]
    pub fn hwlnSPIClass_begin(this: *mut hwlnSPIClass);
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass3endEv"]
    pub fn hwlnSPIClass_end(this: *mut hwlnSPIClass);
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass16beginTransactionER13lnSPISettings"]
    pub fn hwlnSPIClass_beginTransaction(this: *mut hwlnSPIClass, settings: *mut lnSPISettings);
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass14endTransactionEv"]
    pub fn hwlnSPIClass_endTransaction(this: *mut hwlnSPIClass);
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass12beginSessionEi"]
    pub fn hwlnSPIClass_beginSession(this: *mut hwlnSPIClass, bitSize: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass10endSessionEv"]
    pub fn hwlnSPIClass_endSession(this: *mut hwlnSPIClass);
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass11setBitOrderE11spiBitOrder"]
    pub fn hwlnSPIClass_setBitOrder(this: *mut hwlnSPIClass, order: spiBitOrder);
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass11setDataModeE11spiDataMode"]
    pub fn hwlnSPIClass_setDataMode(this: *mut hwlnSPIClass, mode: spiDataMode);
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass8setSpeedEi"]
    pub fn hwlnSPIClass_setSpeed(this: *mut hwlnSPIClass, speed: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass11setDataSizeEi"]
    pub fn hwlnSPIClass_setDataSize(this: *mut hwlnSPIClass, dataSize: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass15asyncDmaWrite16EiPKtPFvPvES2_b"]
    pub fn hwlnSPIClass_asyncDmaWrite16(
        this: *mut hwlnSPIClass,
        nbBytes: cty::c_int,
        data: *const u16,
        cb: lnSpiCallback,
        cookie: *mut cty::c_void,
        repeat: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass14nextDmaWrite16EiPKtPFvPvES2_b"]
    pub fn hwlnSPIClass_nextDmaWrite16(
        this: *mut hwlnSPIClass,
        nbBytes: cty::c_int,
        data: *const u16,
        cb: lnSpiCallback,
        cookie: *mut cty::c_void,
        repeat: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass14finishAsyncDmaEv"]
    pub fn hwlnSPIClass_finishAsyncDma(this: *mut hwlnSPIClass) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass19waitForAsyncDmaDoneEv"]
    pub fn hwlnSPIClass_waitForAsyncDmaDone(this: *mut hwlnSPIClass) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass5writeEi"]
    pub fn hwlnSPIClass_write(this: *mut hwlnSPIClass, z: cty::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass7write16Ei"]
    pub fn hwlnSPIClass_write16(this: *mut hwlnSPIClass, z: cty::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass13write16RepeatEit"]
    pub fn hwlnSPIClass_write16Repeat(
        this: *mut hwlnSPIClass,
        nb: cty::c_int,
        pattern: u16,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass5writeEiPKhb"]
    pub fn hwlnSPIClass_write1(
        this: *mut hwlnSPIClass,
        nbBytes: cty::c_int,
        data: *const u8,
        repeat: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass7write16EiPKtb"]
    pub fn hwlnSPIClass_write161(
        this: *mut hwlnSPIClass,
        nbWord: cty::c_int,
        data: *const u16,
        repeat: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass10dmaWrite16EiPKt"]
    pub fn hwlnSPIClass_dmaWrite16(
        this: *mut hwlnSPIClass,
        nbBytes: cty::c_int,
        data: *const u16,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass16dmaWrite16RepeatEit"]
    pub fn hwlnSPIClass_dmaWrite16Repeat(
        this: *mut hwlnSPIClass,
        nbBytes: cty::c_int,
        data: u16,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass8dmaWriteEiPKh"]
    pub fn hwlnSPIClass_dmaWrite(
        this: *mut hwlnSPIClass,
        nbBytes: cty::c_int,
        data: *const u8,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass8transferEiPhS0_"]
    pub fn hwlnSPIClass_transfer(
        this: *mut hwlnSPIClass,
        nbBytes: cty::c_int,
        dataOut: *mut u8,
        dataIn: *mut u8,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass17waitForCompletionEv"]
    pub fn hwlnSPIClass_waitForCompletion(this: *mut hwlnSPIClass);
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass9read1wireEiPh"]
    pub fn hwlnSPIClass_read1wire(this: *mut hwlnSPIClass, nbRead: cty::c_int, rd: *mut u8)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass18getPeripheralClockEv"]
    pub fn hwlnSPIClass_getPeripheralClock(this: *mut hwlnSPIClass) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12hwlnSPIClass7misoPinEv"]
    pub fn hwlnSPIClass_misoPin(this: *const hwlnSPIClass) -> lnPin;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12hwlnSPIClass7mosiPinEv"]
    pub fn hwlnSPIClass_mosiPin(this: *const hwlnSPIClass) -> lnPin;
}
extern "C" {
    #[link_name = "\u{1}_ZNK12hwlnSPIClass6clkPinEv"]
    pub fn hwlnSPIClass_clkPin(this: *const hwlnSPIClass) -> lnPin;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass5setupEv"]
    pub fn hwlnSPIClass_setup(this: *mut hwlnSPIClass);
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass4csOnEv"]
    pub fn hwlnSPIClass_csOn(this: *mut hwlnSPIClass);
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass5csOffEv"]
    pub fn hwlnSPIClass_csOff(this: *mut hwlnSPIClass);
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass8exTxDoneEPvN5lnDMA16DmaInterruptTypeE"]
    pub fn hwlnSPIClass_exTxDone(c: *mut cty::c_void, it: lnDMA_DmaInterruptType);
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass13writeInternalEii"]
    pub fn hwlnSPIClass_writeInternal(
        this: *mut hwlnSPIClass,
        sz: cty::c_int,
        data: cty::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass14writesInternalEiiPKhb"]
    pub fn hwlnSPIClass_writesInternal(
        this: *mut hwlnSPIClass,
        sz: cty::c_int,
        nbBytes: cty::c_int,
        data: *const u8,
        repeat: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass16dmaWriteInternalEiiPKhb"]
    pub fn hwlnSPIClass_dmaWriteInternal(
        this: *mut hwlnSPIClass,
        wordSize: cty::c_int,
        nbBytes: cty::c_int,
        data: *const u8,
        repeat: bool,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass6txDoneEv"]
    pub fn hwlnSPIClass_txDone(this: *mut hwlnSPIClass);
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClass14invokeCallbackEv"]
    pub fn hwlnSPIClass_invokeCallback(this: *mut hwlnSPIClass);
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClassC1Eii"]
    pub fn hwlnSPIClass_hwlnSPIClass(
        this: *mut hwlnSPIClass,
        instance: cty::c_int,
        pinCs: cty::c_int,
    );
}
impl hwlnSPIClass {
    #[inline]
    pub unsafe fn begin(&mut self) {
        hwlnSPIClass_begin(self)
    }
    #[inline]
    pub unsafe fn end(&mut self) {
        hwlnSPIClass_end(self)
    }
    #[inline]
    pub unsafe fn beginTransaction(&mut self, settings: *mut lnSPISettings) {
        hwlnSPIClass_beginTransaction(self, settings)
    }
    #[inline]
    pub unsafe fn endTransaction(&mut self) {
        hwlnSPIClass_endTransaction(self)
    }
    #[inline]
    pub unsafe fn beginSession(&mut self, bitSize: cty::c_int) {
        hwlnSPIClass_beginSession(self, bitSize)
    }
    #[inline]
    pub unsafe fn endSession(&mut self) {
        hwlnSPIClass_endSession(self)
    }
    #[inline]
    pub unsafe fn setBitOrder(&mut self, order: spiBitOrder) {
        hwlnSPIClass_setBitOrder(self, order)
    }
    #[inline]
    pub unsafe fn setDataMode(&mut self, mode: spiDataMode) {
        hwlnSPIClass_setDataMode(self, mode)
    }
    #[inline]
    pub unsafe fn setSpeed(&mut self, speed: cty::c_int) {
        hwlnSPIClass_setSpeed(self, speed)
    }
    #[inline]
    pub unsafe fn setDataSize(&mut self, dataSize: cty::c_int) {
        hwlnSPIClass_setDataSize(self, dataSize)
    }
    #[inline]
    pub unsafe fn asyncDmaWrite16(
        &mut self,
        nbBytes: cty::c_int,
        data: *const u16,
        cb: lnSpiCallback,
        cookie: *mut cty::c_void,
        repeat: bool,
    ) -> bool {
        hwlnSPIClass_asyncDmaWrite16(self, nbBytes, data, cb, cookie, repeat)
    }
    #[inline]
    pub unsafe fn nextDmaWrite16(
        &mut self,
        nbBytes: cty::c_int,
        data: *const u16,
        cb: lnSpiCallback,
        cookie: *mut cty::c_void,
        repeat: bool,
    ) -> bool {
        hwlnSPIClass_nextDmaWrite16(self, nbBytes, data, cb, cookie, repeat)
    }
    #[inline]
    pub unsafe fn finishAsyncDma(&mut self) -> bool {
        hwlnSPIClass_finishAsyncDma(self)
    }
    #[inline]
    pub unsafe fn waitForAsyncDmaDone(&mut self) -> bool {
        hwlnSPIClass_waitForAsyncDmaDone(self)
    }
    #[inline]
    pub unsafe fn write(&mut self, z: cty::c_int) -> bool {
        hwlnSPIClass_write(self, z)
    }
    #[inline]
    pub unsafe fn write16(&mut self, z: cty::c_int) -> bool {
        hwlnSPIClass_write16(self, z)
    }
    #[inline]
    pub unsafe fn write16Repeat(&mut self, nb: cty::c_int, pattern: u16) -> bool {
        hwlnSPIClass_write16Repeat(self, nb, pattern)
    }
    #[inline]
    pub unsafe fn write1(&mut self, nbBytes: cty::c_int, data: *const u8, repeat: bool) -> bool {
        hwlnSPIClass_write1(self, nbBytes, data, repeat)
    }
    #[inline]
    pub unsafe fn write161(&mut self, nbWord: cty::c_int, data: *const u16, repeat: bool) -> bool {
        hwlnSPIClass_write161(self, nbWord, data, repeat)
    }
    #[inline]
    pub unsafe fn dmaWrite16(&mut self, nbBytes: cty::c_int, data: *const u16) -> bool {
        hwlnSPIClass_dmaWrite16(self, nbBytes, data)
    }
    #[inline]
    pub unsafe fn dmaWrite16Repeat(&mut self, nbBytes: cty::c_int, data: u16) -> bool {
        hwlnSPIClass_dmaWrite16Repeat(self, nbBytes, data)
    }
    #[inline]
    pub unsafe fn dmaWrite(&mut self, nbBytes: cty::c_int, data: *const u8) -> bool {
        hwlnSPIClass_dmaWrite(self, nbBytes, data)
    }
    #[inline]
    pub unsafe fn transfer(
        &mut self,
        nbBytes: cty::c_int,
        dataOut: *mut u8,
        dataIn: *mut u8,
    ) -> bool {
        hwlnSPIClass_transfer(self, nbBytes, dataOut, dataIn)
    }
    #[inline]
    pub unsafe fn waitForCompletion(&mut self) {
        hwlnSPIClass_waitForCompletion(self)
    }
    #[inline]
    pub unsafe fn read1wire(&mut self, nbRead: cty::c_int, rd: *mut u8) -> bool {
        hwlnSPIClass_read1wire(self, nbRead, rd)
    }
    #[inline]
    pub unsafe fn getPeripheralClock(&mut self) -> cty::c_int {
        hwlnSPIClass_getPeripheralClock(self)
    }
    #[inline]
    pub unsafe fn misoPin(&self) -> lnPin {
        hwlnSPIClass_misoPin(self)
    }
    #[inline]
    pub unsafe fn mosiPin(&self) -> lnPin {
        hwlnSPIClass_mosiPin(self)
    }
    #[inline]
    pub unsafe fn clkPin(&self) -> lnPin {
        hwlnSPIClass_clkPin(self)
    }
    #[inline]
    pub unsafe fn setup(&mut self) {
        hwlnSPIClass_setup(self)
    }
    #[inline]
    pub unsafe fn csOn(&mut self) {
        hwlnSPIClass_csOn(self)
    }
    #[inline]
    pub unsafe fn csOff(&mut self) {
        hwlnSPIClass_csOff(self)
    }
    #[inline]
    pub unsafe fn exTxDone(c: *mut cty::c_void, it: lnDMA_DmaInterruptType) {
        hwlnSPIClass_exTxDone(c, it)
    }
    #[inline]
    pub unsafe fn writeInternal(&mut self, sz: cty::c_int, data: cty::c_int) -> bool {
        hwlnSPIClass_writeInternal(self, sz, data)
    }
    #[inline]
    pub unsafe fn writesInternal(
        &mut self,
        sz: cty::c_int,
        nbBytes: cty::c_int,
        data: *const u8,
        repeat: bool,
    ) -> bool {
        hwlnSPIClass_writesInternal(self, sz, nbBytes, data, repeat)
    }
    #[inline]
    pub unsafe fn dmaWriteInternal(
        &mut self,
        wordSize: cty::c_int,
        nbBytes: cty::c_int,
        data: *const u8,
        repeat: bool,
    ) -> bool {
        hwlnSPIClass_dmaWriteInternal(self, wordSize, nbBytes, data, repeat)
    }
    #[inline]
    pub unsafe fn txDone(&mut self) {
        hwlnSPIClass_txDone(self)
    }
    #[inline]
    pub unsafe fn invokeCallback(&mut self) {
        hwlnSPIClass_invokeCallback(self)
    }
    #[inline]
    pub unsafe fn new(instance: cty::c_int, pinCs: cty::c_int) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        hwlnSPIClass_hwlnSPIClass(__bindgen_tmp.as_mut_ptr(), instance, pinCs);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN12hwlnSPIClassD1Ev"]
    pub fn hwlnSPIClass_hwlnSPIClass_destructor(this: *mut hwlnSPIClass);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lnStopWatch {
    pub _start: cty::c_ulong,
    pub _end: cty::c_ulong,
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnStopWatch7restartEi"]
    pub fn lnStopWatch_restart(this: *mut lnStopWatch, durationMs: cty::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnStopWatch7elapsedEv"]
    pub fn lnStopWatch_elapsed(this: *mut lnStopWatch) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN11lnStopWatchC1Ei"]
    pub fn lnStopWatch_lnStopWatch(this: *mut lnStopWatch, ms: cty::c_int);
}
impl lnStopWatch {
    #[inline]
    pub unsafe fn restart(&mut self, durationMs: cty::c_int) -> bool {
        lnStopWatch_restart(self, durationMs)
    }
    #[inline]
    pub unsafe fn elapsed(&mut self) -> bool {
        lnStopWatch_elapsed(self)
    }
    #[inline]
    pub unsafe fn new(ms: cty::c_int) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnStopWatch_lnStopWatch(__bindgen_tmp.as_mut_ptr(), ms);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lnCycleClock {
    pub _start: cty::c_ulong,
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnCycleClock7restartEv"]
    pub fn lnCycleClock_restart(this: *mut lnCycleClock);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnCycleClock7elapsedEv"]
    pub fn lnCycleClock_elapsed(this: *mut lnCycleClock) -> cty::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnCycleClockC1Ev"]
    pub fn lnCycleClock_lnCycleClock(this: *mut lnCycleClock);
}
impl lnCycleClock {
    #[inline]
    pub unsafe fn restart(&mut self) {
        lnCycleClock_restart(self)
    }
    #[inline]
    pub unsafe fn elapsed(&mut self) -> cty::c_ulong {
        lnCycleClock_elapsed(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnCycleClock_lnCycleClock(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
pub type lnTimerIrq = ::core::option::Option<unsafe extern "C" fn(cookie: *mut cty::c_void)>;
pub const lnTimerMode_lnTimerModePwm0: lnTimerMode = 0;
pub const lnTimerMode_lnTimerModePwm1: lnTimerMode = 1;
pub type lnTimerMode = cty::c_uint;
#[repr(C)]
pub struct lnTimer__bindgen_vtable(cty::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct lnTimer {
    pub vtable_: *const lnTimer__bindgen_vtable,
    pub _timer: cty::c_int,
    pub _channel: cty::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer10setPwmModeEi"]
    pub fn lnTimer_setPwmMode(this: *mut lnTimer, ratio100: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer15setPwmFrequencyEi"]
    pub fn lnTimer_setPwmFrequency(this: *mut lnTimer, fqInHz: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer15setChannelRatioEi"]
    pub fn lnTimer_setChannelRatio(this: *mut lnTimer, ratio100: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer10singleShotEib"]
    pub fn lnTimer_singleShot(this: *mut lnTimer, durationMs: cty::c_int, down: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer13setForceStateEb"]
    pub fn lnTimer_setForceState(this: *mut lnTimer, forceHigh: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer7disableEv"]
    pub fn lnTimer_disable(this: *mut lnTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer6enableEv"]
    pub fn lnTimer_enable(this: *mut lnTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer16setTickFrequencyEi"]
    pub fn lnTimer_setTickFrequency(this: *mut lnTimer, fqInHz: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimer7setModeE11lnTimerMode"]
    pub fn lnTimer_setMode(this: *mut lnTimer, mode: lnTimerMode);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimerC1Eii"]
    pub fn lnTimer_lnTimer(this: *mut lnTimer, timer: cty::c_int, channel: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimerC1Ei"]
    pub fn lnTimer_lnTimer1(this: *mut lnTimer, pin: cty::c_int);
}
impl lnTimer {
    #[inline]
    pub unsafe fn setPwmMode(&mut self, ratio100: cty::c_int) {
        lnTimer_setPwmMode(self, ratio100)
    }
    #[inline]
    pub unsafe fn setPwmFrequency(&mut self, fqInHz: cty::c_int) {
        lnTimer_setPwmFrequency(self, fqInHz)
    }
    #[inline]
    pub unsafe fn setChannelRatio(&mut self, ratio100: cty::c_int) {
        lnTimer_setChannelRatio(self, ratio100)
    }
    #[inline]
    pub unsafe fn singleShot(&mut self, durationMs: cty::c_int, down: bool) {
        lnTimer_singleShot(self, durationMs, down)
    }
    #[inline]
    pub unsafe fn setForceState(&mut self, forceHigh: bool) {
        lnTimer_setForceState(self, forceHigh)
    }
    #[inline]
    pub unsafe fn disable(&mut self) {
        lnTimer_disable(self)
    }
    #[inline]
    pub unsafe fn enable(&mut self) {
        lnTimer_enable(self)
    }
    #[inline]
    pub unsafe fn setTickFrequency(&mut self, fqInHz: cty::c_int) {
        lnTimer_setTickFrequency(self, fqInHz)
    }
    #[inline]
    pub unsafe fn setMode(&mut self, mode: lnTimerMode) {
        lnTimer_setMode(self, mode)
    }
    #[inline]
    pub unsafe fn new(timer: cty::c_int, channel: cty::c_int) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnTimer_lnTimer(__bindgen_tmp.as_mut_ptr(), timer, channel);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(pin: cty::c_int) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnTimer_lnTimer1(__bindgen_tmp.as_mut_ptr(), pin);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN7lnTimerD1Ev"]
    pub fn lnTimer_lnTimer_destructor(this: *mut lnTimer);
}
#[repr(C)]
#[derive(Debug)]
pub struct lnAdcTimer {
    pub _base: lnTimer,
    pub _actualPwmFrequency: cty::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnAdcTimer15setPwmFrequencyEi"]
    pub fn lnAdcTimer_setPwmFrequency(this: *mut lnAdcTimer, fqInHz: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnAdcTimer15getPwmFrequencyEv"]
    pub fn lnAdcTimer_getPwmFrequency(this: *mut lnAdcTimer) -> cty::c_int;
}
impl lnAdcTimer {
    #[inline]
    pub unsafe fn setPwmFrequency(&mut self, fqInHz: cty::c_int) {
        lnAdcTimer_setPwmFrequency(self, fqInHz)
    }
    #[inline]
    pub unsafe fn getPwmFrequency(&mut self) -> cty::c_int {
        lnAdcTimer_getPwmFrequency(self)
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct lnSquareSignal {
    pub _base: lnTimer,
}
extern "C" {
    #[link_name = "\u{1}_ZN14lnSquareSignal12setFrequencyEi"]
    pub fn lnSquareSignal_setFrequency(this: *mut lnSquareSignal, fqInHz: cty::c_int);
}
impl lnSquareSignal {
    #[inline]
    pub unsafe fn setFrequency(&mut self, fqInHz: cty::c_int) {
        lnSquareSignal_setFrequency(self, fqInHz)
    }
}
#[repr(C)]
pub struct lnDmaTimerCallback__bindgen_vtable(cty::c_void);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lnDmaTimerCallback {
    pub vtable_: *const lnDmaTimerCallback__bindgen_vtable,
}
#[repr(C)]
#[derive(Debug)]
pub struct lnDmaTimer {
    pub _base: lnTimer,
    pub _cb: *mut lnDmaTimerCallback,
    pub _rollover: cty::c_int,
    pub _dma: *mut lnDMA,
    pub _bits: cty::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimer8pwmSetupEi"]
    pub fn lnDmaTimer_pwmSetup(this: *mut lnDmaTimer, frequency: cty::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimer8rolloverEv"]
    pub fn lnDmaTimer_rollover(this: *mut lnDmaTimer) -> cty::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimer17attachDmaCallbackEP18lnDmaTimerCallback"]
    pub fn lnDmaTimer_attachDmaCallback(this: *mut lnDmaTimer, cb: *mut lnDmaTimerCallback)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimer5startEiPh"]
    pub fn lnDmaTimer_start(this: *mut lnDmaTimer, nbSample: cty::c_int, data: *mut u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimer4stopEv"]
    pub fn lnDmaTimer_stop(this: *mut lnDmaTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimer16setTickFrequencyEi"]
    pub fn lnDmaTimer_setTickFrequency(this: *mut lnDmaTimer, fq: cty::c_int) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimer12dmaInterruptEb"]
    pub fn lnDmaTimer_dmaInterrupt(this: *mut lnDmaTimer, h: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimerC1Eii"]
    pub fn lnDmaTimer_lnDmaTimer(this: *mut lnDmaTimer, bits: cty::c_int, pin: lnPin);
}
impl lnDmaTimer {
    #[inline]
    pub unsafe fn pwmSetup(&mut self, frequency: cty::c_int) -> bool {
        lnDmaTimer_pwmSetup(self, frequency)
    }
    #[inline]
    pub unsafe fn rollover(&mut self) -> cty::c_int {
        lnDmaTimer_rollover(self)
    }
    #[inline]
    pub unsafe fn attachDmaCallback(&mut self, cb: *mut lnDmaTimerCallback) -> bool {
        lnDmaTimer_attachDmaCallback(self, cb)
    }
    #[inline]
    pub unsafe fn start(&mut self, nbSample: cty::c_int, data: *mut u8) -> bool {
        lnDmaTimer_start(self, nbSample, data)
    }
    #[inline]
    pub unsafe fn stop(&mut self) {
        lnDmaTimer_stop(self)
    }
    #[inline]
    pub unsafe fn setTickFrequency(&mut self, fq: cty::c_int) -> bool {
        lnDmaTimer_setTickFrequency(self, fq)
    }
    #[inline]
    pub unsafe fn dmaInterrupt(&mut self, h: bool) {
        lnDmaTimer_dmaInterrupt(self, h)
    }
    #[inline]
    pub unsafe fn new(bits: cty::c_int, pin: lnPin) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnDmaTimer_lnDmaTimer(__bindgen_tmp.as_mut_ptr(), bits, pin);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN10lnDmaTimerD1Ev"]
    pub fn lnDmaTimer_lnDmaTimer_destructor(this: *mut lnDmaTimer);
}
#[repr(C)]
#[derive(Debug)]
pub struct lnDelayTimer {
    pub _base: lnTimer,
    pub _handler: lnTimerIrq,
    pub _cookie: *mut cty::c_void,
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnDelayTimer3armEi"]
    pub fn lnDelayTimer_arm(this: *mut lnDelayTimer, delayUs: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnDelayTimer12setInterruptEPFvPvES0_"]
    pub fn lnDelayTimer_setInterrupt(
        this: *mut lnDelayTimer,
        handler: lnTimerIrq,
        cookie: *mut cty::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnDelayTimer16interruptHandlerEi"]
    pub fn lnDelayTimer_interruptHandler(timer: cty::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnDelayTimer3irqEv"]
    pub fn lnDelayTimer_irq(this: *mut lnDelayTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnDelayTimer15enableInterruptEv"]
    pub fn lnDelayTimer_enableInterrupt(this: *mut lnDelayTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnDelayTimer16disableInterruptEv"]
    pub fn lnDelayTimer_disableInterrupt(this: *mut lnDelayTimer);
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnDelayTimerC1Eii"]
    pub fn lnDelayTimer_lnDelayTimer(
        this: *mut lnDelayTimer,
        timer: cty::c_int,
        channel: cty::c_int,
    );
}
impl lnDelayTimer {
    #[inline]
    pub unsafe fn arm(&mut self, delayUs: cty::c_int) {
        lnDelayTimer_arm(self, delayUs)
    }
    #[inline]
    pub unsafe fn setInterrupt(&mut self, handler: lnTimerIrq, cookie: *mut cty::c_void) {
        lnDelayTimer_setInterrupt(self, handler, cookie)
    }
    #[inline]
    pub unsafe fn interruptHandler(timer: cty::c_int) {
        lnDelayTimer_interruptHandler(timer)
    }
    #[inline]
    pub unsafe fn irq(&mut self) {
        lnDelayTimer_irq(self)
    }
    #[inline]
    pub unsafe fn enableInterrupt(&mut self) {
        lnDelayTimer_enableInterrupt(self)
    }
    #[inline]
    pub unsafe fn disableInterrupt(&mut self) {
        lnDelayTimer_disableInterrupt(self)
    }
    #[inline]
    pub unsafe fn new(timer: cty::c_int, channel: cty::c_int) -> Self {
        let mut __bindgen_tmp = ::core::mem::MaybeUninit::uninit();
        lnDelayTimer_lnDelayTimer(__bindgen_tmp.as_mut_ptr(), timer, channel);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN12lnDelayTimerD1Ev"]
    pub fn lnDelayTimer_lnDelayTimer_destructor(this: *mut lnDelayTimer);
}
unsafe impl Send for lnFastEventGroup {}
unsafe impl Sync for lnFastEventGroup {}
